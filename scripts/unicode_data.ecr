# This file was automatically generated by running:
#
#   scripts/generate_unicode_data.cr
#
# DO NOT EDIT

module Unicode
  # Most case conversions map a range to another range.
  # Here we store: {from, to, delta}
  @@upcase_ranges : Array({Int32, Int32, Int32})?

  private def self.upcase_ranges
    @@upcase_ranges ||= begin
      data = Array({Int32, Int32, Int32}).new(<%= upcase_ranges.size %>)
      <%- upcase_ranges.each do |range| -%>
        put(data, <%= range.low %>, <%= range.high %>, <%= range.delta %>)
      <%- end -%>
      data
    end
  end

  # Most case conversions map a range to another range.
  # Here we store: {from, to, delta}
  @@downcase_ranges : Array({Int32, Int32, Int32})?

  private def self.downcase_ranges
    @@downcase_ranges ||= begin
      data = Array({Int32, Int32, Int32}).new(<%= downcase_ranges.size %>)
      <%- downcase_ranges.each do |range| -%>
        put(data, <%= range.low %>, <%= range.high %>, <%= range.delta %>)
      <%- end -%>
      data
    end
  end

  # Other case conversions run in an alternated range
  # of uppercase/lowercase transformations
  # Here we store {from, to}
  @@alternate_ranges : Array({Int32, Int32})?

  private def self.alternate_ranges
    @@alternate_ranges ||= begin
      data = Array({Int32, Int32}).new(<%= alternate_ranges.size %>)
      <%- alternate_ranges.each do |range| -%>
        put(data, <%= range.low %>, <%= range.high %>)
      <%- end -%>
      data
    end
  end

  # We store categories as consecutive strides {from, to, stride}
  #
  # For example, in this case:
  #
  #   {1, 10, 1}
  #   {11, 15, 2}
  #
  # The values are: 1..10, 11, 13, 15

  <%- all_strides.each do |category, strides| -%>
    @@category_<%= category %> : Array({Int32, Int32, Int32})?

    private def self.category_<%= category %>
      @@category_<%= category %> ||= begin
        data = Array({Int32, Int32, Int32}).new(<%= strides.size %>)
        <%- strides.each do |stride| -%>
          put(data, <%= stride.low %>, <%= stride.high %>, <%= stride.stride %>)
        <%- end -%>
        data
      end
    end
  <%- end %>

  # Most casefold conversions map a range to another range.
  # Here we store: {from, to, delta}
  @@casefold_ranges : Array({Int32, Int32, Int32})?

  private def self.casefold_ranges
    @@casefold_ranges ||= begin
      data = Array({Int32, Int32, Int32}).new(<%= casefold_ranges.size %>)
      <%- casefold_ranges.each do |range| -%>
        put(data, <%= range.low %>, <%= range.high %>, <%= range.delta %>)
      <%- end -%>
      data
    end
  end

  # Special downcase transformation that involve mapping a codepoint
  # to multiple codepoints. The maximum transformation is always 3
  # codepoints, so we store them all as 3 codepoints and 0 means end.
  @@special_cases_downcase : Hash(Int32, {Int32, Int32, Int32})?

  private def self.special_cases_downcase
    @@special_cases_downcase ||= begin
      data = Hash(Int32, {Int32, Int32, Int32}).new(initial_capacity: <%= special_cases_downcase.size %>)
      <%- special_cases_downcase.each do |a_case| -%>
        put(data, <%= a_case.codepoint %>, <%= a_case.value.join(", ") %>)
      <%- end %>
      data
    end
  end

  # Special upcase transformation that involve mapping a codepoint
  # to multiple codepoints. The maximum transformation is always 3
  # codepoints, so we store them all as 3 codepoints and 0 means end.
  @@special_cases_upcase : Hash(Int32, {Int32, Int32, Int32})?

  private def self.special_cases_upcase
    @@special_cases_upcase ||= begin
      data = Hash(Int32, {Int32, Int32, Int32}).new(initial_capacity: <%= special_cases_upcase.size %>)
      <%- special_cases_upcase.each do |a_case| -%>
        put(data, <%= a_case.codepoint %>, <%= a_case.value.join(", ") %>)
      <%- end %>
      data
    end
  end

  # Fold case transformation that involve mapping a codepoint
  # to multiple codepoints. The maximum transformation is always 4
  # codepoints, so we store them all as 4 codepoints and 0 means end.
  @@fold_cases : Hash(Int32, {Int32, Int32, Int32, Int32})?
  private def self.fold_cases
    @@fold_cases ||= begin
      data = Hash(Int32, {Int32, Int32, Int32, Int32}).new(initial_capacity: <%= special_cases_casefold.size %>)
      <%- special_cases_casefold.each do |a_case| -%>
        put(data, <%= a_case.codepoint %>, <%= a_case.value.join(", ") %>)
      <%- end -%>
      data
    end
  end

  # TODO: this is needed to avoid generating lots of allocas
  # in LLVM, which makes LLVM really slow. The compiler should
  # try to avoid/reuse temporary allocas.
  # Explanation: https://github.com/crystal-lang/crystal/issues/4516#issuecomment-306226171
  private def self.put(array : Array, *values) : Nil
    array << values
  end

  private def self.put(hash : Hash, key, *values) : Nil
    hash[key] = values
  end
end
