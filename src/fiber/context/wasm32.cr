{% skip_file unless flag?(:wasm32) %}

require "crystal/asyncify"

# WebAssembly as built by LLVM has 3 stacks:
# - A value stack for low level operations. Wasm is a stack machine. For example: to write data to
#   memory you first push the target address, then the value, then perform the 'store' instruction.
# - A stack with private frames. Each function has access to a stack frame accessed with the local.get
#   and local.set instructions. These frames are private and can't be manipulated outside of the function.
# - A shadow stack in the main memory. It is controlled by a stack_pointer global and grows down. This
#   is not a feature of WebAssembly, just a convention that LLVM uses.
#
# There is a proposal to add stack switching to WebAssembly, but as of this writing it is not standardized
# and isn't implemented by any runtime. See details at https://github.com/WebAssembly/stack-switching.
#
# Here we use an alternative implementation on top of Binaryen's Asyncify pass. It is a static transformation
# on the WebAssembly file that must be performed after the Crystal program is compiled. It rewrites every
# relevant function so that it writes its stack frame to memory and rewinds to the caller, as well as
# recovering the stack from memory. It is all controlled by a global state variable.
# Please read more details at https://github.com/WebAssembly/binaryen/blob/main/src/passes/Asyncify.cpp.
#
# Stack switching is accomplished by the cooperation between two functions: Fiber.swapcontext and
# Crystal::Asyncify.wrap_main. Before they are explained, the memory layout must be understood:
#
# +--------+--------+------------------+----------------
# | Unused | Data   | Main stack       | Heap ...
# +--------+--------+------------------+----------------
# |        |        |                  |
# 0    __data_start |              __heap_base
#              __data_end        __stack_pointer
#
# The first 1024 bytes of memory are unused (but they are usable, including the address 0!). Follows
# the static data like constant strings. This would be read only data on other platforms, but here it
# is writable. The special symbols `__data_start` and `__data_end` are generated by LLVM to mark this
# region. Then follows the main stack. A `__heap_base` symbol points to the bottom of this stack. The
# global `__stack_pointer` starts at this position and is moved by the program during execution.
# After that, the rest of the memory follows, used mainly by malloc. It is important to note that
# during execution everything is just memory, there is no real difference between those sections.
#
# For our implementation of stack switching, this is the memory layout on every fiber stack:
#
# +--------+---------------------------+------------------------+
# | Header | Asyncify buffer =>        |               <= Stack |
# +--------+---------------------------+------------------------+
#
# The header stores 4 pointers as metadata:
#  - [0] => A function pointer to fiber_main
#  - [1] => A the closure data of fiber_main
#  - [2] => The current position on the asyncify buffer (starts after the header, grows up)
#  - [4] => The end position on the asyncify buffer (the current stack top)
# On the main stack all of them are guaranteed to start null.
#
# Stack switching happens as follows:
#
# 1. CrystalMain calls Crystal::Asyncify.wrap_main, passing a proc to the main function. This
#    proc is invoked immediately.
# 2. At some point a new Fiber will be created and Fiber.swapcontext will be called. It will:
#    a. store the current value of `__stack_pointer`.
#    b. update the `__stack_pointer` global to the stack_top of the target context.
#    c. update the asyncify buffer to be the region of memory between the header and the stack_top.
#    d. trigger a stack unwinding, targeting the entrypoint and the asyncify buffer of the target
#       fiber, if any.
# 4. As a consequence of the Asyncify transformation, all functions behave differently and instead
#    of executing, they will write their local stack to the Asyncify buffer and return.
# 5. At some point execution will arrive at Crystal::Asyncify.wrap_main again. We stop the unwind
#    process. If there is a target asyncify buffer, setup the rewinding process. Then call into the
#    fiber main function, resuming or starting it.

lib LibC
  $__data_end : UInt8
end

private def get_main_stack_low
  pointerof(LibC.__data_end).as(Void*)
end

class Fiber
  struct Context
    property stack_low : Void* = get_main_stack_low

    private def ctx_data_ptr
      @stack_low.as(Void**)
    end

    def asyncify_data_ptr
      (ctx_data_ptr + 2).as(LibAsyncify::Data*)
    end

    def fiber_main
      return nil if ctx_data_ptr[0].null?
      Proc(Void).new(ctx_data_ptr[0], ctx_data_ptr[1])
    end

    def fiber_main=(value : ->)
      ctx_data_ptr[0] = value.pointer
      ctx_data_ptr[1] = value.closure_data
    end
  end

  # :nodoc:
  def makecontext(stack_ptr : Void**, fiber_main : Fiber ->)
    @context.stack_top = stack_ptr.as(Void*)
    @context.stack_low = (stack_ptr.as(UInt8*) - StackPool::STACK_SIZE + 32).as(Void*)
    @context.resumable = 1
    func = ->{
      fiber_main.call(self)
      Intrinsics.debugtrap # A fiber function shall never return
    }
    @context.fiber_main = func
    asyncify_data_ptr = @context.asyncify_data_ptr
    asyncify_data_ptr.value.current_location = Pointer(Void).null
    asyncify_data_ptr.value.end_location = Pointer(Void).null
  end

  # :nodoc:
  @[NoInline]
  def self.swapcontext(current_context, next_context) : Nil
    current_context.value.stack_top = Crystal::Asyncify.stack_pointer
    Crystal::Asyncify.stack_pointer = next_context.value.stack_top

    current_context.value.resumable = 1
    current_asyncify_data_ptr = current_context.value.asyncify_data_ptr
    current_asyncify_data_ptr.value.current_location = (current_context.value.stack_low.as(Void**) + 4).as(Void*)
    current_asyncify_data_ptr.value.end_location = current_context.value.stack_top

    next_context.value.resumable = 0
    next_asyncify_data_ptr = next_context.value.asyncify_data_ptr

    Crystal::Asyncify.unwind(
      unwind_data: current_asyncify_data_ptr,
      rewind_data: next_asyncify_data_ptr.value.current_location.null? ? nil : next_asyncify_data_ptr,
      rewind_func: next_context.value.fiber_main || Crystal::Asyncify.main_func
    )
  end
end
