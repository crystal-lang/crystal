# :nodoc:
struct CallStack
  # DWARF reader.
  #
  # Documentation:
  # - <http://dwarfstd.org>
  #
  # :nodoc:
  module DWARF
    # Standard Line Number opcodes.
    enum LNS : UInt8
      Copy = 1
      AdvancePc = 2
      AdvanceLine = 3
      SetFile = 4
      SetColumn = 5
      NegateStmt = 6
      SetBasicBlock = 7
      ConstAddPc = 8
      FixedAdvancePc = 9
      SetPrologueEnd = 10
      SetEpiloqueBegin = 11
      SetIsa = 12
    end

    # Extended Line Number opcodes.
    enum LNE : UInt8
      EndSequence = 1
      SetAddress = 2
      DefineFile = 3
      SetDiscriminator = 4
    end

    # Line Numbers parser. Supports DWARF versions 2, 3 and 4.
    #
    # Documentation:
    # - [DWARF2](http://dwarfstd.org/doc/dwarf-2.0.0.pdf) section 6.2
    # - [DWARF3](http://dwarfstd.org/doc/Dwarf3.pdf) section 6.2
    # - [DWARF4](http://dwarfstd.org/doc/DWARF4.pdf) section 6.2
    struct LineNumbers
      # The state machine registers used to decompress the line number
      # sequences.
      #
      # :nodoc:
      struct Register
        # The Program Counter (PC) value corresponding to a machine instruction
        # generated by the compiler.
        property address : UInt64

        # The index of an operation inside a Very Long Instruction Word (VLIW)
        # instruction. Together with `address` they reference an individual
        # operation.
        property op_index : UInt32

        # Source file for the instruction.
        property file : UInt32

        # Line number within the source file. Starting at 1; the value 0 means
        # that the instruction can't be attributed to any source line.
        property line : UInt32

        # Column number within the source file. Starting at 1; the value 0 means
        # that a statement begins at the "left edge" of the line.
        property column : UInt32

        # Recommended breakpoint location.
        property is_stmt : Bool

        # Indicates that the instruction is the beginning of a basic block.
        property basic_block : Bool

        # Terminates a sequence of lines. Other information in the same row (of
        # the decoded matrix) isn't meaningful.
        property end_sequence : Bool

        # Indicates the the instruction is one where execution should be
        # suspended (for an entry breakpoint).
        property prologue_end : Bool

        # Indicates the the instruction is one where execution should be
        # suspended (for an exit breakpoint).
        property epilogue_begin : Bool

        # Applicable Instruction Set Architecture for the instruction.
        property isa : UInt32

        # Identifies the block to which the instruction belongs.
        property discriminator : UInt32

        def initialize(@is_stmt)
          @address = 0_u64
          @op_index = 0_u32
          @file = 1_u32
          @line = 1_u32
          @column = 0_u32
          @basic_block = false
          @end_sequence = false
          @prologue_end = false
          @epilogue_begin = false
          @isa = 0_u32
          @discriminator = 0_u32
        end

        def reset
          @basic_block = false
          @prologue_end = false
          @epilogue_begin = false
          @discriminator = 0_u32
        end
      end

      # The decoded line number information for an instruction.
      record Row,
        address : UInt64,
        op_index : UInt32,
        directory : Int32,
        file : Int32,
        line : Int32,
        column : Int32,
        end_sequence : Bool

      # An individual compressed sequence.
      #
      # :nodoc:
      struct Sequence
        property! offset : Int64
        property! unit_length : UInt32
        property! version : UInt16
        property! header_length : UInt32 # FIXME: UInt64 for DWARF64 (uncommon)
        property! minimum_instruction_length : UInt8
        property  maximum_operations_per_instruction : UInt8
        property! default_is_stmt : Bool
        property! line_base : Int8
        property! line_range : UInt8
        property! opcode_base : UInt8

        # An array of how many args an array. Starts at 1 because 0 means an
        # extended opcode.
        getter standard_opcode_lengths

        # An array of directory names. Starts at 1; 0 means that the information
        # is missing.
        getter include_directories

        # An array of file names. Starts at 1; 0 means that the information is
        # missing.
        getter file_names

        def initialize
          @maximum_operations_per_instruction = 1_u8
          @include_directories = [""]
          @file_names = [{"", 0, 0, 0}]
          @standard_opcode_lengths = [0_u8]
        end
      end

      # Matrix of decompressed Row to search line number informations from
      # the address of an instruction.
      #
      # The matrix contains indexed references to `directories` and `files`
      # in order to limit the memory usage by repeating a String many times.
      #
      # Each mapping is `{address, dir, file, line, column, discriminator}`.
      getter matrix : Array(Row)

      # The array of indexed directory paths.
      getter directories : Array(String)

      # The array of indexed file names.
      getter files : Array(String)

      @offset : Int64

      def initialize(@io : IO::FileDescriptor, sh_size)
        @offset = @io.tell
        @matrix = [] of Row
        @directories = [] of String
        @files = [] of String
        decode_sequences(sh_size)
      end

      # Returns the `Row` for the given Program Counter (PC) address if found.
      def find(address)
        if row = matrix.first?
          return if address < row.address
        end

        if row = matrix.last?
          return if address > row.address
        end

        matrix.each_with_index do |current_row, index|
          if current_row.address == address
            return current_row
          end

          if address < current_row.address
            if previous_row = matrix[index - 1]?
              return previous_row unless previous_row.end_sequence
            end
            return
          end
        end

        nil
      end

      # Decodes the compressed matrix of addresses to line numbers.
      private def decode_sequences(sh_size)
        while (@io.tell - @offset) < sh_size
          sequence = read_sequence
        end
      end

      private def read_sequence
        sequence = Sequence.new

        sequence.offset = @io.tell - @offset
        sequence.unit_length = @io.read_bytes(UInt32)
        sequence.version = @io.read_bytes(UInt16)
        sequence.header_length = @io.read_bytes(UInt32)
        sequence.minimum_instruction_length = @io.read_byte.not_nil!

        if sequence.version >= 4
          sequence.maximum_operations_per_instruction = @io.read_byte.not_nil!
        end

        sequence.default_is_stmt = @io.read_byte.not_nil! == 1
        sequence.line_base = @io.read_bytes(Int8)
        sequence.line_range = @io.read_byte.not_nil!
        sequence.opcode_base = @io.read_byte.not_nil!

        read_opcodes(sequence)
        read_directory_table(sequence)
        read_filename_table(sequence)

        if @io.tell - @offset < sequence.offset + sequence.unit_length
          read_statement_program(sequence)
        end

        sequence
      end

      private def read_opcodes(sequence)
        1.upto(sequence.opcode_base - 1) do |i|
          sequence.standard_opcode_lengths << @io.read_byte.not_nil!
        end
      end

      private def read_directory_table(sequence)
        loop do
          name = @io.gets('\0').to_s.chomp('\0')
          break if name.empty?
          sequence.include_directories << name
        end
      end

      private def read_filename_table(sequence)
        loop do
          name = @io.gets('\0').to_s.chomp('\0')
          break if name.empty?
          dir = read_unsigned_leb128
          time = read_unsigned_leb128
          length = read_unsigned_leb128
          sequence.file_names << {name, dir.to_i, time.to_i, length.to_i}
        end
      end

      # :nodoc:
      macro increment_address_and_op_index(operation_advance)
        if sequence.maximum_operations_per_instruction == 1
          registers.address += {{operation_advance}} * sequence.minimum_instruction_length
        else
          registers.address += sequence.minimum_instruction_length *
            ((registers.op_index + operation_advance) / sequence.maximum_operations_per_instruction)
          registers.op_index = (registers.op_index + operation_advance) % sequence.maximum_operations_per_instruction
        end
      end

      private def read_statement_program(sequence)
        registers = Register.new(sequence.default_is_stmt)

        loop do
          opcode = @io.read_byte.not_nil!

          if opcode >= sequence.opcode_base
            # special opcode
            adjusted_opcode = opcode - sequence.opcode_base
            operation_advance = adjusted_opcode / sequence.line_range # FIXME: Crystal 0.19 requires '//'
            increment_address_and_op_index(operation_advance)
            #registers.address += (adjusted_opcode / sequence.line_range) * sequence.minimum_instruction_length

            registers.line += sequence.line_base + (adjusted_opcode % sequence.line_range)
            register_to_matrix(sequence, registers)
            registers.reset
          elsif opcode == 0
            # extended opcode
            len = read_unsigned_leb128 - 1 # -1 accounts for the opcode
            extended_opcode = LNE.new(@io.read_byte.not_nil!)

            case extended_opcode
            when LNE::EndSequence
              registers.end_sequence = true
              register_to_matrix(sequence, registers)
              if (@io.tell - @offset - sequence.offset) < sequence.unit_length
                registers = Register.new(sequence.default_is_stmt)
              else
                break
              end
            when LNE::SetAddress
              case len
              when 8 then registers.address = @io.read_bytes(UInt64)
              when 4 then registers.address = @io.read_bytes(UInt32).to_u64
              else @io.skip(len)
              end
              registers.op_index = 0_u32
            #when LNE::DefineFile
            #  TODO: manually register file to files table
            #  filename = @io.gets('\0').to_s.chomp('\0')
            #  dir = read_unsigned_leb128
            #  time = read_unsigned_leb128
            #  length = read_unsigned_leb128
            when LNE::SetDiscriminator
              registers.discriminator = read_unsigned_leb128
            else
              # skip unsupported opcode
              @io.read_fully(extended = Bytes.new(len))
            end
          else
            # standard opcode
            standard_opcode = LNS.new(opcode)

            case standard_opcode
            when LNS::Copy
              register_to_matrix(sequence, registers)
              registers.reset
            when LNS::AdvancePc
              operation_advance = read_unsigned_leb128
              #registers.address += operation_advance * sequence.minimum_instruction_length
              increment_address_and_op_index(operation_advance)
            when LNS::AdvanceLine
              registers.line += read_signed_leb128
            when LNS::SetFile
              registers.file = read_unsigned_leb128
            when LNS::SetColumn
              registers.column = read_unsigned_leb128
            when LNS::NegateStmt
              registers.is_stmt = !registers.is_stmt
            when LNS::SetBasicBlock
              registers.basic_block = true
            when LNS::ConstAddPc
              adjusted_opcode = 255 - sequence.opcode_base
              operation_advance = adjusted_opcode / sequence.line_range # FIXME: Crystal 0.19 requires '//'
              #registers.address += operation_advance * sequence.minimum_instruction_length
              increment_address_and_op_index(operation_advance)
            when LNS::FixedAdvancePc
              registers.address += @io.read_bytes(UInt16).not_nil!
              registers.op_index = 0_u32
            when LNS::SetPrologueEnd
              registers.prologue_end = true
            when LNS::SetEpiloqueBegin
              registers.epilogue_begin = true
            when LNS::SetIsa
              registers.isa = read_unsigned_leb128
            else
              # consume unknown opcode args
              n_args = sequence.standard_opcode_lengths[opcode.to_i]
              n_args.times { read_unsigned_leb128 }
            end
          end
        end
      end

      private def read_unsigned_leb128
        result = 0_u32
        shift = 0

        loop do
          byte = @io.read_byte.not_nil!.to_i
          result |= (byte & 0x7f) << shift
          break if byte.bit(7) == 0
          shift += 7
        end

        result
      end

      private def read_signed_leb128
        result = 0_i32
        shift = 0
        size = 32
        byte = 0_u8

        loop do
          byte = @io.read_byte.not_nil!.to_i
          result |= (byte & 0x7f) << shift
          shift += 7
          break if byte.bit(7) == 0
        end

        # sign bit of byte is 2nd high order bit (0x40)
        if (shift < size) && (byte.bit(6) == 1)
          # sign extend
          result |= - (1 << shift);
        end

        result
      end

      private def register_to_matrix(sequence, registers)
        file = sequence.file_names[registers.file]
        path = sequence.include_directories[file[1]]
        matrix << Row.new(
          registers.address,
          registers.op_index,
          register_directory(path),
          register_filename(file[0]),
          registers.line.to_i,
          registers.column.to_i,
          registers.end_sequence
        )
      end

      private def register_filename(name)
        if index = @files.index(name)
          return index
        end
        @files << name
        @files.size - 1
      end

      private def register_directory(name)
        if index = @directories.index(name)
          return index
        end
        @directories << name
        @directories.size - 1
      end

    end
  end
end
