require "../program"
require "../syntax/ast"
require "../syntax/visitor"
require "./*"

module Crystal
  class Program
    def infer_type(node)
      node.accept TypeVisitor.new(self)
      expand_def_macros
      fix_empty_types node
      after_type_inference node
    end
  end

  class TypeVisitor < Visitor
    ThreadLocalAttributes = %w(ThreadLocal)
    ValidGlobalAttributes = ThreadLocalAttributes
    ValidExternalVarAttributes = ThreadLocalAttributes
    ValidClassVarAttributes = ThreadLocalAttributes
    ValidStructDefAttributes = %w(Packed)
    ValidDefAttributes = %w(AlwaysInline NoInline Raises ReturnsTwice)
    ValidFunDefAttributes = %w(AlwaysInline NoInline Raises ReturnsTwice)
    ValidEnumDefAttributes = %w(Flags)

    getter mod
    property! scope
    getter! typed_def
    property! untyped_def
    getter block
    property call
    property type_lookup
    property fun_literal_context
    property parent
    property types
    property block_nest

    # These are the free variables that came from matches. We look up
    # here first if we find a single-element Path like `T`.
    property free_vars

    # These are the variables and types that come from a block specification
    # like `&block : Int32 -> Int32`. When doing `yield 1` we need to verify
    # that the yielded expression has the type that the block specification said.
    property yield_vars

    # In vars we store the types of variables as we traverse the nodes.
    # These type are not cummulative: if you do `x = 1`, 'x' will have
    # type Int32. Then if you do `x = false`, 'x' will have type Bool.
    getter vars

    # Here we store the cummulative types of variables as we traverse the nodes.
    getter meta_vars

    getter is_initialize

    @unreachable = false
    @is_initialize = false

    def initialize(@mod, vars = MetaVars.new, @typed_def = nil, meta_vars = nil)
      @types = [@mod] of Type
      @while_stack = [] of While
      @vars = vars
      @needs_type_filters = 0
      @unreachable = false
      @block_nest = 0
      @typeof_nest = 0
      @is_initialize = !!(typed_def && typed_def.name == "initialize")
      @found_self_in_initialize_call = false
      @used_ivars_in_calls_in_initialize = nil
      @in_type_args = 0
      @attributes  = nil

      # We initialize meta_vars from vars given in the constructor.
      # We store those meta vars either in the typed def or in the program
      # so the codegen phase knows the cummulative types to do allocas.
      unless meta_vars
        if typed_def = @typed_def
          meta_vars = typed_def.vars = MetaVars.new
        else
          meta_vars = @mod.vars
        end
        vars.each do |name, var|
          meta_var = new_meta_var(name)
          meta_var.bind_to(var)
          meta_vars[name] = meta_var
        end
      end

      @meta_vars = meta_vars
    end

    def visit_any(node)
      @unreachable = false
      true
    end

    def visit(node : ASTNode)
      true
    end

    def visit(node : Attribute)
      attributes = @attributes ||= [] of Attribute
      attributes << node
      false
    end

    def end_visit_any(node)
      if @attributes
        case node
        when Expressions
          # Nothing, will be taken care in individual expressions
        when Attribute
          # Nothing
        when Call
          # Don't clear attributes if these were generated by a macro
          unless node.expanded
            @attributes = nil
          end
        else
          @attributes = nil
        end
      end
    end

    def visit(node : Var)
      var = @vars[node.name]?
      if var
        meta_var = @meta_vars[node.name]
        check_closured meta_var

        if var.nil_if_read
          meta_var.bind_to(@mod.nil_var) unless meta_var.dependencies.try &.any? &.same?(@mod.nil_var)
          node.bind_to(@mod.nil_var)
        end

        if meta_var.closured
          var.bind_to(meta_var)
        end

        node.bind_to(var)

        if needs_type_filters?
          @type_filters = TypeFilters.truthy(node)
        end
      elsif node.name == "self"
        current_type = current_type()
        if current_type.is_a?(Program)
          node.raise "there's no self in this scope"
        else
          node.type = current_type.metaclass
        end
      else
        node.raise "read before definition of '#{node.name}'"
      end
    end

    def visit(node : DeclareVar)
      case var = node.var
      when Var
        if @vars[var.name]?
          var.raise "variable '#{var.name}' already declared"
        end

        node.declared_type.accept self
        node.type = check_declare_var_type node

        var.bind_to node

        meta_var = new_meta_var(var.name)
        meta_var.bind_to(var)

        @vars[var.name] = meta_var
        @meta_vars[var.name] = meta_var
      when InstanceVar
        type = scope? || current_type
        if @untyped_def
          node.declared_type.accept self
          node.type = check_declare_var_type node
          ivar = lookup_instance_var var
          ivar.bind_to node
          var.bind_to node

          if @is_initialize
            @vars[var.name] = MetaVar.new(var.name, node.type)
          end
        end

        case type
        when NonGenericClassType
          node.declared_type.accept self
          node.type = check_declare_var_type node
          type.declare_instance_var(var.name, node.type)
        when GenericClassType
          type.declare_instance_var(var.name, node.declared_type)
        when GenericClassInstanceType
          # OK
        else
          node.raise "can only declare instance variables of a non-generic class, not a #{type.type_desc} (#{type})"
        end
      end

      false
    end

    def visit(node : Out)
      case exp = node.exp
      when Var
        # We declare out variables
        # TODO: check that the out variable didn't exist before
        @meta_vars[exp.name] = new_meta_var(exp.name)
        @vars[exp.name] = new_meta_var(exp.name)
      when InstanceVar
        var = lookup_instance_var exp
        exp.bind_to(var)

        if @is_initialize
          @vars[exp.name] = MetaVar.new(exp.name)
        end
      else
        node.raise "Bug: unexpected out exp: #{exp}"
      end

      node.bind_to node.exp

      false
    end

    def check_declare_var_type(node)
      type = node.declared_type.type.instance_type

      if type.is_a?(GenericClassType)
        node.raise "can't declare variable of generic non-instantiated type #{type}"
      end

      type
    end

    def visit(node : Global)
      var = mod.global_vars[node.name]?
      unless var
        var = Var.new(node.name)
        var.bind_to mod.nil_var
        mod.global_vars[node.name] = var
      end
      node.bind_to var
    end

    def visit(node : InstanceVar)
      var = lookup_instance_var node
      node.bind_to(var)

      if @is_initialize && !@vars.has_key? node.name
        ivar = scope.lookup_instance_var(node.name)
        ivar.bind_to @mod.nil_var
      end
    end

    def end_visit(node : ReadInstanceVar)
      obj_type = node.obj.type
      unless obj_type.is_a?(InstanceVarContainer)
        node.raise "#{obj_type} doesn't have instance vars"
      end

      ivar = obj_type.lookup_instance_var?(node.name, false)
      unless ivar
        node.raise "#{obj_type} doesn't have an instance var named '#{node.name}'"
      end

      node.bind_to ivar
    end

    def visit(node : ClassVar)
      class_var = lookup_class_var(node)
      check_valid_attributes class_var, ValidClassVarAttributes, "class variable"

      node.attributes = class_var.attributes
      node.bind_to class_var
    end

    def lookup_instance_var(node)
      case scope = @scope
      when Nil
        node.raise "can't use instance variables at the top level"
      when Program
        node.raise "can't use instance variables at the top level"
      when PrimitiveType
        node.raise "can't use instance variables inside #{scope}"
      when .metaclass?
        node.raise "@instance_vars are not yet allowed in metaclasses: use @@class_vars instead"
      when InstanceVarContainer
        var = scope.lookup_instance_var node.name
        unless scope.has_instance_var_in_initialize?(node.name)
          begin
            var.bind_to mod.nil_var
          rescue ex : Crystal::Exception
            node.raise "#{node} not in initialize so it's nilable", ex
          end
        end
        check_self_closured
        var
      else
        node.raise "Bug: #{scope} is not an InstanceVarContainer"
      end
    end

    def lookup_class_var(node, bind_to_nil_if_non_existent = true)
      class_var_owner = (@scope || current_type).class_var_owner as ClassVarContainer

      bind_to_nil = bind_to_nil_if_non_existent && !class_var_owner.has_class_var?(node.name)

      var = class_var_owner.lookup_class_var node.name
      var.bind_to mod.nil_var if bind_to_nil

      node.owner = class_var_owner
      node.var = var
      node.class_scope = !@typed_def

      var
    end

    def end_visit(node : Expressions)
      node.bind_to node.last unless node.empty?
    end

    def visit(node : Assign)
      type_assign node.target, node.value, node
      false
    end

    def type_assign(target : Var, value, node)
      var_name = target.name

      value.accept self

      value_type_filters = @type_filters
      @type_filters = nil

      target.bind_to value
      node.bind_to value

      meta_var = (@meta_vars[var_name] ||= new_meta_var(var_name))
      meta_var.bind_to value
      meta_var.assigned_to = true
      check_closured meta_var

      simple_var = MetaVar.new(var_name)
      simple_var.bind_to(target)

      if meta_var.closured
        simple_var.bind_to(meta_var)
      end

      @vars[var_name] = simple_var

      # If inside a begin part of an exception handler, bind this type to
      # the variable that will be used in the rescue/else blocks.
      if exception_handler_vars = @exception_handler_vars
        var = (exception_handler_vars[var_name] ||= MetaVar.new(var_name))
        var.bind_to(value)
      end

      if needs_type_filters?
        @type_filters = TypeFilters.and(TypeFilters.truthy(target), value_type_filters)
      end
    end

    def type_assign(target : InstanceVar, value, node)
      # Check if this is an instance variable initializer
      unless @scope
        current_type = current_type()
        if current_type.is_a?(ClassType)
          ivar_visitor = TypeVisitor.new(mod)
          ivar_visitor.scope = current_type
          value.accept ivar_visitor

          current_type.add_instance_var_initializer(target.name, value, ivar_visitor.meta_vars)
          var = current_type.lookup_instance_var(target.name, true)
        end
      end

      unless var
        value.accept self
        var = lookup_instance_var target
      end

      target.bind_to var

      node.bind_to value
      var.bind_to node

      if @is_initialize
        var_name = target.name

        meta_var = (@meta_vars[var_name] ||= new_meta_var(var_name))
        meta_var.bind_to value
        meta_var.assigned_to = true

        simple_var = MetaVar.new(var_name)
        simple_var.bind_to(target)

        used_ivars_in_calls_in_initialize = @used_ivars_in_calls_in_initialize
        if @found_self_in_initialize_call || used_ivars_in_calls_in_initialize.try(&.includes?(var_name)) || (@block_nest > 0 && !@vars.has_key?(var_name))
          ivar = scope.lookup_instance_var(var_name)
          ivar.bind_to @mod.nil_var
        end

        @vars[var_name] = simple_var
      end
    end

    def type_assign(target : Path, value, node)
      type = current_type.types[target.names.first]?
      if type
        target.raise "already initialized constant #{target}"
      end

      target.bind_to value

      const = Const.new(@mod, current_type, target.names.first, value, @types.dup, @scope)
      attach_doc const, node

      current_type.types[target.names.first] = const

      node.type = @mod.nil
      target.target_const = const
    end

    def type_assign(target : Global, value, node)
      check_valid_attributes target, ValidGlobalAttributes, "global variable"

      value.accept self

      var = mod.global_vars[target.name]?
      unless var
        var = Var.new(target.name)
        if @typed_def
          var.bind_to mod.nil_var
        end
        mod.global_vars[target.name] = var
      end
      var.add_attributes(target.attributes)

      target.bind_to var

      node.bind_to value
      var.bind_to node
    end

    def type_assign(target : ClassVar, value, node)
      var = lookup_class_var target, !!@typed_def
      check_valid_attributes var, ValidClassVarAttributes, "class variable"

      value.accept self

      target.attributes = var.attributes
      target.bind_to var

      node.bind_to value
      var.bind_to node
    end

    def type_assign(target, value, node)
      raise "Bug: unknown assign target in type inference: #{target}"
    end

    def visit(node : Def)
      if inside_block?
        node.raise "can't declare def inside block"
      end

      check_valid_attributes node, ValidDefAttributes, "def"
      node.doc ||= attributes_doc()

      target_type = case receiver = node.receiver
                    when Nil
                      current_type
                    when Var
                      unless receiver.name == "self"
                        receiver.raise "def receiver can only be a Type or self"
                      end
                      current_type.metaclass
                    else
                      lookup_path_type(receiver).metaclass
                    end

      node.raises = true if node.has_attribute?("Raises")

      target_type.add_def node
      node.set_type @mod.nil
      false
    end

    def visit(node : Macro)
      if inside_block?
        node.raise "can't declare macro inside block"
      end

      begin
        current_type.metaclass.add_macro node
      rescue ex
        node.raise ex.message
      end

      node.set_type @mod.nil
      false
    end

    def visit(node : Undef)
      unless current_type.undef(node.name)
        node.raise "undefined method #{node.name} for #{current_type.type_desc} #{current_type}"
      end
    end

    def visit(node : Yield)
      if @fun_literal_context
        node.raise "can't yield from function literal"
      end

      call = @call.not_nil!
      block = call.block || node.raise("no block given")

      # This is the case of a yield when there's a captured block
      if block.fun_literal
        block_arg_name = typed_def.block_arg.not_nil!.name
        block_var = Var.new(block_arg_name).at(node.location)
        call = Call.new(block_var, "call", node.exps).at(node.location)
        call.accept self
        node.bind_to call
        node.expanded = call
        return false
      end

      node.scope.try &.accept self
      node.exps.each &.accept self

      if (yield_vars = @yield_vars) && !node.scope
        yield_vars.each_with_index do |var, i|
          exp = node.exps[i]?
          if exp
            # TODO: this should really be var.type.implements?(exp.type)
            if (exp_type = exp.type?) && !exp_type.is_restriction_of?(var.type, exp_type)
              exp.raise "argument ##{i + 1} of yield expected to be #{var.type}, not #{exp_type}"
            end

            exp.freeze_type = var.type
          elsif !var.type.nil_type?
            node.raise "missing argument ##{i + 1} of yield with type #{var.type}"
          end
        end
      end

      bind_block_args_to_yield_exps block, node

      unless block.visited
        call.bubbling_exception do
          if node_scope = node.scope
            block.scope = node_scope.type
          end
          ignoring_type_filters do
            block.accept call.parent_visitor.not_nil!
          end
        end
      end

      node.bind_to block

      @type_filters = nil
      false
    end

    def bind_block_args_to_yield_exps(block, node)
      block.args.each_with_index do |arg, i|
        arg.bind_to(node.exps[i]? || mod.nil_var)
      end
    end

    def visit(node : Block)
      return if node.visited

      node.visited = true
      node.context = current_non_block_context

      before_block_vars = node.vars.try(&.dup) || MetaVars.new

      meta_vars = @meta_vars.dup
      node.args.each do |arg|
        meta_var = new_meta_var(arg.name, context: node)
        meta_var.bind_to(arg)

        # TODO: check if we need a second meta-var
        before_block_vars[arg.name] = meta_var
        meta_vars[arg.name] = meta_var
      end

      @block_nest += 1

      block_visitor = TypeVisitor.new(mod, before_block_vars, @typed_def, meta_vars)
      block_visitor.yield_vars = @yield_vars
      block_visitor.free_vars = @free_vars
      block_visitor.untyped_def = @untyped_def
      block_visitor.call = @call
      block_visitor.fun_literal_context = @fun_literal_context
      block_visitor.parent = self

      block_scope = node.scope || @scope
      block_scope ||= current_type.metaclass unless current_type.is_a?(Program)

      block_visitor.scope = block_scope

      block_visitor.block = node
      block_visitor.type_lookup = type_lookup || current_type
      block_visitor.block_nest = @block_nest

      node.body.accept block_visitor

      @block_nest -= 1

      # Check re-assigned variables and bind them.
      bind_vars block_visitor.vars, node.vars
      bind_vars block_visitor.vars, node.after_vars

      node.vars = meta_vars

      node.bind_to node.body

      false
    end

    def bind_vars(from_vars, to_vars)
      if to_vars
        from_vars.each do |name, block_var|
          to_vars[name]?.try &.bind_to(block_var)
        end
      end
    end

    def visit(node : FunLiteral)
      fun_vars = @vars.dup
      meta_vars = @meta_vars.dup

      node.def.args.each do |arg|
        # It can happen that the argument has a type already,
        # when converting a block to a fun literal
        if restriction = arg.restriction
          restriction.accept self
          arg.type = restriction.type.instance_type.virtual_type
        elsif !arg.type?
          arg.raise "function argument '#{arg.name}' must have a type"
        end

        fun_var = MetaVar.new(arg.name, arg.type)
        fun_vars[arg.name] = fun_var

        meta_var = new_meta_var(arg.name, context: node.def)
        meta_var.bind_to fun_var
        meta_vars[arg.name] = meta_var
      end

      node.bind_to node.def
      node.def.bind_to node.def.body
      node.def.vars = meta_vars

      block_visitor = TypeVisitor.new(mod, fun_vars, node.def, meta_vars)
      block_visitor.types = @types
      block_visitor.yield_vars = @yield_vars
      block_visitor.free_vars = @free_vars
      block_visitor.untyped_def = node.def
      block_visitor.call = @call
      block_visitor.scope = @scope
      block_visitor.type_lookup = type_lookup
      block_visitor.fun_literal_context = @fun_literal_context || @typed_def || @mod
      block_visitor.block_nest = @block_nest
      block_visitor.parent = self

      node.def.body.accept block_visitor

      false
    end

    def visit(node : FunPointer)
      if obj = node.obj
        obj.accept self
      end

      call = Call.new(obj, node.name)
      prepare_call(call)

      call.args = node.args.map_with_index do |arg, i|
        arg.accept self
        Var.new("arg#{i}", arg.type.instance_type) as ASTNode
      end

      begin
        call.recalculate
      rescue ex : Crystal::Exception
        node.raise "error instantiating #{node}", ex
      end

      node.call = call
      node.bind_to call

      false
    end

    def end_visit(node : Fun)
      if inputs = node.inputs
        types = inputs.map &.type.instance_type
      else
        types = [] of Type
      end

      if output = node.output
        types << output.type.instance_type
      else
        types << mod.void
      end

      node.type = mod.fun_of(types)
    end

    def visit(node : Call)
      prepare_call(node)

      if expand_macro(node)
        return false
      end

      check_super_in_initialize node

      obj = node.obj
      args = node.args
      block_arg = node.block_arg
      named_args = node.named_args

      ignoring_type_filters do
        if obj
          obj.accept(self)

          check_lib_call node, obj.type?

          if check_special_new_call(node, obj.type?)
            return false
          end
        end

        args.each &.accept(self)
        block_arg.try &.accept self
        named_args.try &.each &.value.accept self
      end

      obj.try &.add_input_observer(node)
      args.each &.add_input_observer(node)
      block_arg.try &.add_input_observer node
      named_args.try &.each &.value.add_input_observer(node)

      # If the call has a block we need to create a copy of the variables
      # and bind them to the current variables. Then, when visiting
      # the block we will bind more variables to these ones if variables
      # are reassigned.
      if node.block || block_arg
        before_vars = MetaVars.new
        after_vars = MetaVars.new

        @vars.each do |name, var|
          before_var = MetaVar.new(name)
          before_var.bind_to(var)
          before_var.nil_if_read = var.nil_if_read
          before_vars[name] = before_var

          after_var = MetaVar.new(name)
          after_var.bind_to(var)
          after_var.nil_if_read = var.nil_if_read
          after_vars[name] = after_var
          @vars[name] = after_var
        end

        if block = node.block
          block.vars = before_vars
          block.after_vars = after_vars
        else
          node.before_vars = before_vars
        end
      end

      node.recalculate

      check_call_in_initialize node

      @type_filters = nil
      @unreachable = true if node.no_returns?

      false
    end

    def prepare_call(node)
      if node.global
        node.scope = @mod
      else
        node.scope = @scope || current_type.metaclass
      end
      node.parent_visitor = self
    end

    # If it's a super call inside an initialize we treat
    # set instance vars from superclasses to not-nil
    def check_super_in_initialize(node)
      if @is_initialize && node.name == "super" && !node.obj
        superclass = scope.superclass

        while superclass
          superclass.instance_vars_in_initialize.try &.each do |name|
            meta_var = MetaVar.new(name)
            meta_var.bind_to scope.lookup_instance_var(name)
            @vars[name] = meta_var
          end

          superclass = superclass.superclass
        end
      end
    end

    # Check if it's a call to self. In that case, all instance variables
    # not mentioned so far will be considered nil.
    def check_call_in_initialize(node)
      return unless @is_initialize
      return if @typeof_nest > 0

      node_obj = node.obj
      if !node_obj || (node_obj.is_a?(Var) && node_obj.name == "self")
        # Special case: when calling self.class a class method will be invoked
        # and there's no possibility of accessing instance vars, so we ignore this case.
        if node.name == "class" && node.args.empty?
          return
        end

        ivars, found_self = gather_instance_vars_read node
        if found_self
          @found_self_in_initialize_call = true
        elsif ivars
          used_ivars_in_calls_in_initialize = @used_ivars_in_calls_in_initialize
          if used_ivars_in_calls_in_initialize
            @used_ivars_in_calls_in_initialize = used_ivars_in_calls_in_initialize | ivars
          else
            @used_ivars_in_calls_in_initialize = ivars
          end
        end
      end
    end

    # Fill function literal argument types for C functions
    def check_lib_call(node, obj_type)
      return unless obj_type.is_a?(LibType)

      method = nil

      node.args.each_with_index do |arg, index|
        next unless arg.is_a?(FunLiteral)
        next unless arg.def.args.any? { |def_arg| !def_arg.restriction && !def_arg.type? }

        method ||= obj_type.lookup_first_def(node.name, false)
        return unless method

        method_arg = method.args[index]?
        next unless method_arg

        method_arg_type = method_arg.type
        next unless method_arg_type.is_a?(FunInstanceType)

        arg.def.args.each_with_index do |def_arg, def_arg_index|
          if !def_arg.restriction && !def_arg.type?
            def_arg.type = method_arg_type.fun_types[def_arg_index]?
          end
        end
      end
    end

    # Check if it's FunType#new
    def check_special_new_call(node, obj_type)
      return false unless obj_type
      return false unless obj_type.metaclass?

      instance_type = obj_type.instance_type.remove_typedef

      if node.name == "new"
        case instance_type
        when FunInstanceType
          return special_fun_type_new_call(node, instance_type)
        when CStructOrUnionType
          if named_args = node.named_args
            return special_struct_or_union_new_with_named_args(node, instance_type, named_args)
          end
        end
      end

      false
    end

    def special_fun_type_new_call(node, fun_type)
      if node.args.length != 0
        node.raise "wrong number of arguments for #{fun_type}#new (#{node.args.length} for 0)"
      end

      block = node.block
      unless block
        node.raise "#{fun_type}#new is expected to be invoked with a block, but no block was given"
      end

      if block.args.length > fun_type.fun_types.length - 1
        node.raise "wrong number of block arguments for #{fun_type}#new (#{block.args.length} for #{fun_type.fun_types.length - 1})"
      end

      # We create a ->(...) { } from the block
      fun_args = fun_type.arg_types.map_with_index do |arg_type, index|
        block_arg = block.args[index]?
        Arg.new(block_arg.try(&.name) || @mod.new_temp_var_name, type: arg_type)
      end

      fun_def = Def.new("->", fun_args, block.body)
      fun_literal = FunLiteral.new(fun_def).at(node.location)
      fun_literal.expected_return_type = fun_type.return_type
      fun_literal.accept self

      node.bind_to fun_literal
      node.expanded = fun_literal

      true
    end

    # Rewrite:
    #
    #     C::Struct.new arg0: value0, argN: value0
    #
    # To:
    #
    #   temp = C::Struct.new
    #   temp.arg0 = value0
    #   temp.argN = valueN
    #   temp
    def special_struct_or_union_new_with_named_args(node, type, named_args)
      exps = [] of ASTNode

      temp_name = @mod.new_temp_var_name

      new_call = Call.new(node.obj, "new").at(node.location)

      new_assign = Assign.new(Var.new(temp_name), new_call)
      exps << new_assign

      named_args.each do |named_arg|
        assign_call = Call.new(Var.new(temp_name), "#{named_arg.name}=", named_arg.value)
        if loc = named_arg.location
          assign_call.location = loc
          assign_call.name_column_number = loc.column_number
        end
        exps << assign_call
      end

      exps << Var.new(temp_name)

      expanded = Expressions.new(exps)
      expanded.accept self

      node.bind_to expanded
      node.expanded = expanded

      true
    end

    class InstanceVarsCollector < Visitor
      getter ivars
      getter found_self

      def initialize(@scope, @vars)
        @found_self = false
        @in_super = 0
      end

      def visit(node : InstanceVar)
        unless @vars.has_key?(node.name)
          ivars = @ivars ||= Set(String).new
          ivars << node.name
        end
      end

      def visit(node : Var)
        if @in_super == 0 && node.name == "self"
          @found_self = true
        end
        false
      end

      def visit(node : Assign)
        node.value.accept self
        false
      end

      def visit(node : Call)
        obj = node.obj

        # Skip class method
        if obj.is_a?(Var) && obj.name == "self" && node.name == "class" && node.args.empty?
          return false
        end

        visited = @visited

        node.target_defs.try &.each do |target_def|
          if target_def.owner == @scope
            next if visited.try &.includes?(target_def.object_id)

            visited = @visited ||= Set(typeof(object_id)).new
            visited << target_def.object_id

            target_def.body.accept self
          end
        end

        if node.name == "super"
          @in_super += 1
        end

        true
      end

      def end_visit(node : Call)
        if node.name == "super"
          @in_super -= 1
        end
      end

      def visit(node : ASTNode)
        true
      end
    end

    def gather_instance_vars_read(node)
      collector = InstanceVarsCollector.new(scope, @vars)
      node.accept collector
      {collector.ivars, collector.found_self}
    end

    def expand_macro(node)
      return false if node.obj || node.name == "super"

      the_macro = node.lookup_macro
      return false unless the_macro

      generated_nodes = expand_macro(the_macro, node) do
        @mod.expand_macro (@scope || current_type), the_macro, node
      end

      node.expanded = generated_nodes
      node.bind_to generated_nodes

      true
    end

    class PropagateDocVisitor < Visitor
      def initialize(@doc)
      end

      def visit(node : Expressions)
        true
      end

      def visit(node : ClassDef | ModuleDef | EnumDef | Def | FunDef | Alias | Assign)
        node.doc ||= @doc
        false
      end

      def visit(node : ASTNode)
        true
      end
    end

    def visit(node : MacroExpression)
      expand_inline_macro node
    end

    def visit(node : MacroIf)
      expand_inline_macro node
    end

    def visit(node : MacroFor)
      expand_inline_macro node
    end

    def expand_inline_macro(node)
      the_macro = Macro.new("macro_#{node.object_id}", [] of Arg, node).at(node.location)

      generated_nodes = expand_macro(the_macro, node) do
        @mod.expand_macro (@scope || current_type), node
      end

      node.expanded = generated_nodes
      node.bind_to generated_nodes

      false
    end

    def expand_macro(the_macro, node)
      begin
        expanded_macro = yield
      rescue ex : Crystal::Exception
        node.raise "expanding macro", ex
      end

      generated_nodes = @mod.parse_macro_source(expanded_macro, the_macro, node, Set.new(@vars.keys), inside_def: !!@typed_def)

      if node_doc = node.doc
        generated_nodes.accept PropagateDocVisitor.new(node_doc)
      end

      generated_nodes.accept self
      generated_nodes
    end

    def visit(node : Return)
      node.raise "can't return from top level" unless @typed_def
      true
    end

    def end_visit(node : Return)
      typed_def = @typed_def.not_nil!
      if exp = node.exp
        typed_def.bind_to exp
      else
        typed_def.bind_to @mod.nil_var
      end
      @unreachable = true
    end

    def visit(node : Generic)
      node.in_type_args = @in_type_args > 0
      node.scope = @scope

      node.name.accept self

      @in_type_args += 1
      node.type_vars.each &.accept self
      @in_type_args -= 1

      return false if node.type?

      instance_type = node.name.type.instance_type
      unless instance_type.is_a?(GenericClassType)
        node.raise "#{instance_type} is not a generic class, it's a #{instance_type.type_desc}"
      end

      if instance_type.variadic
        min_needed = instance_type.type_vars.length - 1
        if node.type_vars.length < min_needed
          node.raise "wrong number of type vars for #{instance_type} (#{node.type_vars.length} for #{min_needed}..)"
        end
      else
        if instance_type.type_vars.length != node.type_vars.length
          node.raise "wrong number of type vars for #{instance_type} (#{node.type_vars.length} for #{instance_type.type_vars.length})"
        end
      end

      node.instance_type = instance_type
      node.type_vars.each &.add_observer(node)
      node.update

      false
    end

    def end_visit(node : Splat)
      node.bind_to node.exp
    end

    def visit(node : Underscore)
      node.raise "can't use underscore as generic type argument"
    end

    def visit(node : IsA)
      node.obj.accept self

      @in_type_args += 1
      node.const.accept self
      @in_type_args -= 1

      node.type = mod.bool
      const = node.const

      # When doing x.is_a?(A) and A turns out to be a constant (not a type),
      # replace it with a === comparison. Most usually this happens in a case expression.
      if const.is_a?(Path) && const.target_const
        comp = Call.new(const, "===", node.obj).at(node.location)
        comp.accept self
        node.syntax_replacement = comp
        node.bind_to comp
        return
      end

      if needs_type_filters? && (var = get_expression_var(node.obj))
        @type_filters = TypeFilters.new var, SimpleTypeFilter.new(node.const.type)
      end

      false
    end

    def end_visit(node : RespondsTo)
      node.type = mod.bool
      if needs_type_filters? && (var = get_expression_var(node.obj))
        @type_filters = TypeFilters.new var, RespondsToTypeFilter.new(node.name.value)
      end
    end

    # Get the variable of an expression.
    # If it's a variable, it's that variable.
    # If it's an assignment to a variable, it's that variable.
    def get_expression_var(exp)
      case exp
      when Var
        return exp
      when Assign
        target = exp.target
        return target if target.is_a?(Var)
      end
      nil
    end

    def end_visit(node : Cast)
      obj_type = node.obj.type?
      if obj_type.is_a?(PointerInstanceType)
        to_type = node.to.type.instance_type
        if to_type.is_a?(GenericType)
          node.raise "can't cast #{obj_type} to #{to_type}"
        end
      end

      node.obj.add_observer node
      node.update
    end

    def visit(node : ClassDef)
      if inside_block?
        node.raise "can't declare class inside block"
      end

      node_superclass = node.superclass

      if node_superclass
        superclass = lookup_path_type(node_superclass)
      else
        superclass = node.struct ? mod.struct : mod.reference
      end

      if node_superclass.is_a?(Generic)
        unless superclass.is_a?(GenericClassType)
          node_superclass.raise "#{superclass} is not a generic class, it's a #{superclass.type_desc}"
        end

        if node_superclass.type_vars.length != superclass.type_vars.length
          node_superclass.raise "wrong number of type vars for #{superclass} (#{node_superclass.type_vars.length} for #{superclass.type_vars.length})"
        end
      end

      scope, name = process_type_name(node.name)

      type = scope.types[name]?

      if !type && superclass
        if (!!node.struct) != (!!superclass.struct?)
          node.raise "can't make #{node.struct ? "struct" : "class"} '#{node.name}' inherit #{superclass.type_desc} '#{superclass.to_s}'"
        end
      end

      created_new_type = false

      if type
        unless type.is_a?(ClassType)
          node.raise "#{name} is not a #{node.struct ? "struct" : "class"}, it's a #{type.type_desc}"
        end

        if (!!node.struct) != (!!type.struct?)
          node.raise "#{name} is not a #{node.struct ? "struct" : "class"}, it's a #{type.type_desc}"
        end

        if node.superclass && type.superclass != superclass
          node.raise "superclass mismatch for class #{type} (#{superclass} for #{type.superclass})"
        end

        if type_vars = node.type_vars
          if type.is_a?(GenericType)
            type_type_vars = type.type_vars
            if type_vars != type_type_vars
              if type_type_vars.length == 1
                node.raise "type var must be #{type_type_vars.join ", "}, not #{type_vars.join ", "}"
              else
                node.raise "type vars must be #{type_type_vars.join ", "}, not #{type_vars.join ", "}"
              end
            end
          else
            node.raise "#{name} is not a generic #{type.type_desc}"
          end
        end
      else
        case superclass
        when NonGenericClassType
          # OK
        when GenericClassType
          mapping = Hash.zip(superclass.type_vars, (node_superclass as Generic).type_vars)
          superclass = InheritedGenericClass.new(@mod, superclass, mapping)
        else
          node_superclass.not_nil!.raise "#{superclass} is not a class, it's a #{superclass.type_desc}"
        end

        created_new_type = true
        if type_vars = node.type_vars
          type = GenericClassType.new @mod, scope, name, superclass, type_vars, false
        else
          type = NonGenericClassType.new @mod, scope, name, superclass, false
        end
        type.abstract = node.abstract
        type.struct = node.struct

        if superclass.is_a?(InheritedGenericClass)
          superclass.extending_class = type
        end

        scope.types[name] = type
      end

      attach_doc type, node

      pushing_type(type) do
        if created_new_type
          run_hooks(superclass.metaclass, type, :inherited, node)
        end

        node.body.accept self
      end

      if created_new_type
        raise "Bug" unless type.is_a?(InheritableClass)
        type.force_add_subclass
      end

      node.type = @mod.nil

      false
    end

    def attach_doc(type, node)
      return unless @mod.wants_doc?

      type.doc ||= node.doc
      if node_location = node.location
        type.locations << node_location
      end
    end

    def run_hooks(type_with_hooks, current_type, kind, node)
      hooks = type_with_hooks.hooks
      if hooks
        hooks.each do |hook|
          next if hook.kind != kind

          expanded = expand_macro(hook.macro, node) do
            @mod.expand_macro current_type.instance_type, hook.macro.body
          end
          expanded.accept self
          node.add_runtime_initializer(expanded)
        end
      end

      if kind == :inherited && (superclass = type_with_hooks.instance_type.superclass)
        run_hooks(superclass.metaclass, current_type, kind, node)
      end
    end

    def visit(node : ModuleDef)
      if inside_block?
        node.raise "can't declare module inside block"
      end

      scope, name = process_type_name(node.name)

      type = scope.types[name]?
      if type
        unless type.module?
          node.raise "#{name} is not a module, it's a #{type.type_desc}"
        end
      else
        if type_vars = node.type_vars
          type = GenericModuleType.new @mod, scope, name, type_vars
        else
          type = NonGenericModuleType.new @mod, scope, name
        end
        scope.types[name] = type
      end

      attach_doc type, node

      pushing_type(type) do
        node.body.accept self
      end

      node.type = @mod.nil

      false
    end

    def visit(node : Alias)
      if inside_block?
        node.raise "can't declare alias inside block"
      end

      alias_type = AliasType.new(@mod, current_type, node.name)

      attach_doc alias_type, node

      current_type.types[node.name] = alias_type
      node.value.accept self
      alias_type.aliased_type = node.value.type.instance_type

      node.type = @mod.nil

      false
    end

    def visit(node : Include)
      if inside_block?
        node.raise "can't include inside block"
      end

      include_in current_type, node, :included

      node.type = @mod.nil

      false
    end

    def visit(node : Extend)
      if inside_block?
        node.raise "can't extend inside block"
      end

      include_in current_type.metaclass, node, :extended

      node.type = @mod.nil

      false
    end

    def visit(node : LibDef)
      if inside_block?
        node.raise "can't declare lib inside block"
      end

      link_attributes = process_link_attributes

      type = current_type.types[node.name]?
      if type
        node.raise "#{node.name} is not a lib" unless type.is_a?(LibType)
      else
        type = LibType.new @mod, current_type, node.name, link_attributes
        current_type.types[node.name] = type
      end

      pushing_type(type) do
        node.body.accept self
      end

      node.type = @mod.nil

      false
    end

    def process_link_attributes
      attributes = @attributes
      return unless attributes

      link_attributes = attributes.map do |attr|
        link_attribute_from_node(attr)
      end
      @attributes = nil
      link_attributes
    end

    def link_attribute_from_node(attr)
      name = attr.name
      args = attr.args
      named_args = attr.named_args

      if name != "Link"
        attr.raise "illegal attribute for lib, valid attributes are: Link"
      end

      if args.empty? && !named_args
        attr.raise "missing link arguments: must at least specify a library name"
      end

      lib_name = nil
      lib_ldflags = nil
      lib_static = false
      lib_framework = nil
      count = 0

      args.each do |arg|
        case count
        when 0
          unless arg.is_a?(StringLiteral)
            arg.raise "'lib' link argument must be a String"
          end
          lib_name = arg.value
        when 1
          unless arg.is_a?(StringLiteral)
            arg.raise "'ldflags' link argument must be a String"
          end
          lib_ldflags = arg.value
        when 2
          unless arg.is_a?(BoolLiteral)
            arg.raise "'static' link argument must be a Bool"
          end
          lib_static = arg.value
        when 3
          unless arg.is_a?(StringLiteral)
            arg.raise "'framework' link argument must be a String"
          end
          lib_framework = arg.value
        else
          attr.raise "wrong number of link arguments (#{args.length} for 1..4)"
        end

        count += 1
      end

      named_args.try &.each do |named_arg|
        value = named_arg.value

        case named_arg.name
        when "lib"
          if count > 0
            named_arg.raise "'lib' link argument already specified"
          end
          unless value.is_a?(StringLiteral)
            named_arg.raise "'lib' link argument must be a String"
          end
          lib_name = value.value
        when "ldflags"
          if count > 1
            named_arg.raise "'ldflags' link argument already specified"
          end
          unless value.is_a?(StringLiteral)
            named_arg.raise "'ldflags' link argument must be a String"
          end
          lib_ldflags = value.value
        when "static"
          if count > 2
            named_arg.raise "'static' link argument already specified"
          end
          unless value.is_a?(BoolLiteral)
            named_arg.raise "'static' link argument must be a Bool"
          end
          lib_static = value.value
        when "framework"
          if count > 3
            named_arg.raise "'framework' link argument already specified"
          end
          unless value.is_a?(StringLiteral)
            named_arg.raise "'framework' link argument must be a String"
          end
          lib_framework = value.value
        else
          named_arg.raise "unkonwn link argument: '#{named_arg.name}' (valid arguments are 'lib', 'ldflags', 'static' and 'framework')"
        end
      end

      LinkAttribute.new(lib_name, lib_ldflags, lib_static, lib_framework)
    end

    def visit(node : FunDef)
      if inside_block?
        node.raise "can't declare fun inside block"
      end

      if node.body && !current_type.is_a?(Program)
        node.raise "can only declare fun at lib or global scope"
      end

      check_valid_attributes node, ValidDefAttributes, "fun"

      args = node.args.map do |arg|
        restriction = arg.restriction.not_nil!
        restriction.accept self

        arg_type = check_primitive_like(restriction.not_nil!)

        Arg.new(arg.name, type: arg_type).at(arg.location)
      end

      node_return_type = node.return_type
      if node_return_type
        node_return_type.accept self
        return_type = check_primitive_like(node_return_type)
      else
        return_type = @mod.void
      end

      external = External.for_fun(node.name, node.real_name, args, return_type, node.varargs, node.body, node)
      external.doc = node.doc

      if node_body = node.body
        vars = MetaVars.new
        args.each do |arg|
          var = MetaVar.new(arg.name, arg.type)
          var.bind_to var
          vars[arg.name] = var
        end
        external.set_type(nil)

        visitor = TypeVisitor.new(@mod, vars, external)
        visitor.untyped_def = external
        visitor.scope = @mod
        visitor.block_nest = @block_nest

        begin
          node_body.accept visitor
        rescue ex : Crystal::Exception
          node.raise ex.message, ex
        end

        inferred_return_type = @mod.type_merge([node_body.type?, external.type?])

        if return_type && return_type != @mod.void && inferred_return_type != return_type
          node.raise "expected fun to return #{return_type} but it returned #{inferred_return_type}"
        end

        external.set_type(return_type)
      end

      external.raises = true if node.has_attribute?("Raises")

      begin
        old_external = current_type.add_def external
      rescue ex
        node.raise ex.message
      end

      if old_external.is_a?(External)
        old_external.dead = true
      end

      if node.body
        key = DefInstanceKey.new external.object_id, external.args.map(&.type), nil, nil
        current_type.add_def_instance key, external
      end

      node.type = @mod.nil

      false
    end

    def end_visit(node : TypeDef)
      type = current_type.types[node.name]?
      if type
        node.raise "#{node.name} is already defined"
      else
        typed_def_type = check_primitive_like node.type_spec
        current_type.types[node.name] = TypeDefType.new @mod, current_type, node.name, typed_def_type
      end
    end

    def visit(node : StructDef)
      check_valid_attributes node, ValidStructDefAttributes, "struct"

      type = process_struct_or_union_def(node, CStructType) do |t|
        unless t.is_a?(CStructType)
          node.raise "#{node.name} is already defined as #{t.type_desc}"
        end
      end
      if node.has_attribute?("Packed")
        (type as CStructType).packed = true
      end

      false
    end

    def visit(node : UnionDef)
      process_struct_or_union_def(node, CUnionType) do |t|
        unless t.is_a?(CUnionType)
          node.raise "#{node.name} is already defined as #{t.type_desc}"
        end
      end

      false
    end

    def visit(node : EnumDef)
      if inside_block?
        node.raise "can't declare enum inside block"
      end

      check_valid_attributes node, ValidEnumDefAttributes, "enum"

      scope, name = process_type_name(node.name)

      enum_type = scope.types[name]?
      if enum_type
        unless enum_type.is_a?(EnumType)
          node.raise "#{name} is not a enum, it's a #{enum_type.type_desc}"
        end
      end

      if base_type = node.base_type
        base_type.accept self
        enum_base_type = base_type.type.instance_type
        unless enum_base_type.is_a?(IntegerType)
          base_type.raise "enum base type must be an integer type"
        end
      else
        enum_base_type = @mod.int32
      end

      is_flags = node.has_attribute?("Flags")
      all_value = 0_u64
      existed = !!enum_type
      enum_type ||= EnumType.new(@mod, scope, name, enum_base_type, is_flags)

      attach_doc enum_type, node

      enum_type.doc ||= attributes_doc()

      pushing_type(enum_type) do
        counter = is_flags ? 1 : 0
        node.members.each do |member|
          case member
          when Arg
            if existed
              member.raise "can't reopen enum and add more constants to it"
            end

            if default_value = member.default_value
              counter = interpret_enum_value(default_value)
            end
            all_value |= counter
            const_value = NumberLiteral.new(counter, enum_base_type.kind)
            member.default_value = const_value
            if enum_type.types.has_key?(member.name)
              member.raise "enum '#{enum_type}' already contains a member named '#{member.name}'"
            end
            const_member = enum_type.add_constant member
            const_member.doc = member.doc

            const_value.type = enum_type
            counter = is_flags ? counter * 2 : counter + 1
          when Def
            member.accept self
          end
        end
      end

      unless existed
        if is_flags
          unless enum_type.types["None"]?
            none = NumberLiteral.new(0, enum_base_type.kind)
            none.type = enum_type
            enum_type.add_constant Arg.new("None", default_value: none)
          end

          unless enum_type.types["All"]?
            all = NumberLiteral.new(all_value, enum_base_type.kind)
            all.type = enum_type
            enum_type.add_constant Arg.new("All", default_value: all)
          end
        end

        node.enum_type = scope.types[name] = enum_type
      end

      node.type = mod.nil

      false
    end

    def interpret_enum_value(node : NumberLiteral)
      case node.kind
      when :i8, :i16, :i32, :i64, :u8, :u16, :u32, :u64
        node.value.to_i
      else
        node.raise "enum constant value must be an integer, not #{node.kind}"
      end
    end

    def interpret_enum_value(node : Call)
      obj = node.obj
      unless obj
        node.raise "invalid enum constant value"
      end
      if node.args.length != 1
        node.raise "invalid enum constant value"
      end

      left = interpret_enum_value(obj)
      right = interpret_enum_value(node.args.first)

      case node.name
      when "+"  then left + right
      when "-"  then left - right
      when "*"  then left * right
      when "/"  then left / right
      when "&"  then left & right
      when "|"  then left | right
      when "<<" then left << right
      when ">>" then left >> right
      when "%"  then left % right
      else
        node.raise "invalid enum constant value"
      end
    end

    def interpret_enum_value(node : Path)
      type = resolve_ident(node)
      case type
      when Const
        interpret_enum_value(type.value)
      else
        node.raise "invalid enum constant value"
      end
    end

    def interpret_enum_value(node : ASTNode)
      node.raise "invalid enum constant value"
    end

    def visit(node : ExternalVar)
      check_valid_attributes node, ValidExternalVarAttributes, "external var"

      node.type_spec.accept self

      var_type = check_primitive_like node.type_spec

      type = current_type as LibType
      type.add_var node.name, var_type, (node.real_name || node.name), node.attributes

      false
    end

    def visit(node : Path)
      type = resolve_ident(node)
      case type
      when Const
        if !type.value.type? && !type.visited?
          type.visited = true

          meta_vars = MetaVars.new
          const_def = Def.new("const", [] of Arg)
          type_visitor = TypeVisitor.new(@mod, meta_vars, const_def)
          type_visitor.types = type.scope_types
          type_visitor.scope = type.scope

          type.value.accept type_visitor
          type.vars = const_def.vars
        end
        node.target_const = type
        node.bind_to type.value
        type.used = true
      when Type
        node.type = check_type_in_type_args(type.remove_alias_if_simple)
      when ASTNode
        node.syntax_replacement = type
        node.bind_to type
      end
    end

    def end_visit(node : Union)
      node.type = @mod.type_merge(node.types.map &.type.instance_type)
    end

    def end_visit(node : Virtual)
      node.type = check_type_in_type_args node.name.type.instance_type.virtual_type
    end

    def end_visit(node : Metaclass)
      node.type = node.name.type.virtual_type!.metaclass
    end

    def check_type_in_type_args(type)
      if @in_type_args > 0
        type
      else
        type.metaclass
      end
    end

    def visit(node : If)
      request_type_filters do
        node.cond.accept self
      end

      cond_type_filters = @type_filters
      cond_vars = @vars

      @type_filters = nil
      @vars = cond_vars.dup
      @unreachable = false

      filter_vars cond_type_filters

      node.then.accept self

      then_vars = @vars
      then_type_filters = @type_filters
      @type_filters = nil
      then_unreachable = @unreachable

      @vars = cond_vars.dup
      @unreachable = false

      # The only cases where we can deduce something for the 'else'
      # block is when the condition is a Var (in the else it must be
      # nil), IsA (in the else it's not that type) or RespondsTo
      # (in the else it doesn't respond to that message).
      case node.cond
      when Var, IsA, RespondsTo
        filter_vars cond_type_filters, &.not
      end

      node.else.accept self

      else_vars = @vars
      else_type_filters = @type_filters
      @type_filters = nil
      else_unreachable = @unreachable

      merge_if_vars node, cond_vars, then_vars, else_vars, then_unreachable, else_unreachable

      if needs_type_filters?
        case node.binary
        when :and
          @type_filters = TypeFilters.and(cond_type_filters, then_type_filters, else_type_filters)
        # TODO: or type filters
        # when :or
        #   node.type_filters = or_type_filters(node.then.type_filters, node.else.type_filters)
        end
      end

      @unreachable = then_unreachable && else_unreachable

      node.bind_to [node.then, node.else]

      false
    end

    # Here we merge the variables from both branches of an if.
    # We basically:
    #   - Create a variable whose type is the merged types of the last
    #     type of each branch.
    #   - Make the variable nilable if the variable wasn't declared
    #     before the 'if' and it doesn't appear in one of the branches.
    #   - Don't use the type of a branch that is unreachable (ends with return,
    #     break or with a call that is NoReturn)
    def merge_if_vars(node, cond_vars, then_vars, else_vars, then_unreachable, else_unreachable)
      all_vars_names = Set(String).new
      then_vars.each_key do |name|
        all_vars_names << name
      end
      else_vars.each_key do |name|
        all_vars_names << name
      end

      all_vars_names.each do |name|
        cond_var = cond_vars[name]?
        then_var = then_vars[name]?
        else_var = else_vars[name]?

        # Check wether the var didn't change at all
        next if then_var.same?(else_var)

        if_var = MetaVar.new(name)
        if_var.nil_if_read = !!(then_var.try(&.nil_if_read) || else_var.try(&.nil_if_read))

        if then_var && else_var
          if then_unreachable
            if_var.bind_to conditional_no_return(node.then, then_var)
          else
            if_var.bind_to then_var
          end

          if else_unreachable
            if_var.bind_to conditional_no_return(node.else, else_var)
          else
            if_var.bind_to else_var
          end
        elsif then_var
          if then_unreachable
            if_var.bind_to conditional_no_return(node.then, then_var)
          else
            if_var.bind_to then_var
          end

          if cond_var
            if_var.bind_to cond_var
          elsif !else_unreachable
            if_var.bind_to @mod.nil_var
            if_var.nil_if_read = true
          else
            if_var.bind_to conditional_no_return(node.else, @mod.nil_var)
          end
        elsif else_var
          if else_unreachable
            if_var.bind_to conditional_no_return(node.else, else_var)
          else
            if_var.bind_to else_var
          end

          if cond_var
            if_var.bind_to cond_var
          elsif !then_unreachable
            if_var.bind_to @mod.nil_var
            if_var.nil_if_read = true
          else
            if_var.bind_to conditional_no_return(node.then, @mod.nil_var)
          end
        end

        @vars[name] = if_var
      end
    end

    def conditional_no_return(node, var)
       node.filtered_by NoReturnFilter.new(var)
    end

    def visit(node : While)
      old_while_vars = @while_vars
      before_cond_vars = @vars.dup

      request_type_filters do
        node.cond.accept self
      end

      cond_type_filters = @type_filters

      after_cond_vars = @vars.dup
      @while_vars = after_cond_vars

      filter_vars cond_type_filters

      @type_filters = nil
      @block, old_block = nil, @block

      @while_stack.push node
      node.body.accept self

      endless_while = node.cond.true_literal?
      merge_while_vars endless_while, before_cond_vars, after_cond_vars, @vars, node.break_vars

      @while_stack.pop
      @block = old_block
      @while_vars = old_while_vars


      unless node.has_breaks
        if endless_while
          node.type = mod.no_return
          return
        end
      end

      node.type = @mod.nil

      false
    end

    # Here we assign the types of variables after a while.
    def merge_while_vars(endless, before_cond_vars, after_cond_vars, while_vars, all_break_vars)
      after_while_vars = MetaVars.new

      while_vars.each do |name, while_var|
        before_cond_var = before_cond_vars[name]?
        after_cond_var = after_cond_vars[name]?

        # If a variable was assigned in the condition, it has that type.
        if after_cond_var && !after_cond_var.same?(before_cond_var)
          after_while_var = MetaVar.new(name)
          after_while_var.bind_to(after_cond_var)
          after_while_var.nil_if_read = after_cond_var.nil_if_read
          after_while_vars[name] = after_while_var

        # If there was a previous variable, we use that type merged
        # with the last type inside the while.
        elsif before_cond_var
          before_cond_var.bind_to(while_var)
          after_while_var = MetaVar.new(name)

          # If the loop is endless
          if endless
            after_while_var.bind_to(while_var)
            after_while_var.nil_if_read = while_var.nil_if_read
          else
            after_while_var.bind_to(before_cond_var)
            after_while_var.bind_to(while_var)
            after_while_var.nil_if_read = before_cond_var.nil_if_read || while_var.nil_if_read
          end
          after_while_vars[name] = after_while_var

        # Otherwise, it's a new variable inside the while: used
        # outside it must be nilable, unless the loop is endless.
        else
          after_while_var = MetaVar.new(name)
          after_while_var.bind_to(while_var)
          nilable = false
          if endless
            # In an endless loop if there's a break before a variable is declared,
            # that variable becomes nilable.
            unless all_break_vars.try &.all? &.has_key?(name)
              nilable = true
            end
          else
            nilable = true
          end
          if nilable
            after_while_var.bind_to(@mod.nil_var)
            after_while_var.nil_if_read = true
          end
          after_while_vars[name] = after_while_var
        end
      end

      @vars = after_while_vars

      # We also need to merge types from breaks inside while.
      if all_break_vars
        all_break_vars.each do |break_vars|
          break_vars.each do |name, var|
            @vars[name].bind_to(var)
          end
        end
      end
    end

    # If we have:
    #
    #   if a
    #     ...
    #   end
    #
    # then inside the if 'a' must not be nil.
    #
    # This is what we do here: we create a meta-variable for
    # it and filter it accordingly. This also applied to
    # .is_a? and .responds_to?.
    #
    # This also applies to 'while' conditions and also
    # to the else part of an if, but with filters inverted.
    def filter_vars(filters)
      filter_vars(filters) { |filter| filter }
    end

    def filter_vars(filters)
      filters.try &.each do |name, filter|
        existing_var = @vars[name]
        filtered_var = MetaVar.new(name)
        filtered_var.bind_to(existing_var.filtered_by(yield filter))
        @vars[name] = filtered_var
      end
    end

    def end_visit(node : Break)
      container = @while_stack.last? || (block.try &.break)
      node.raise "Invalid break" unless container

      if container.is_a?(While)
        container.has_breaks = true

        break_vars = (container.break_vars = container.break_vars || [] of MetaVars)
        break_vars.push @vars.dup
      else
        if exp = node.exp
          container.bind_to(exp)
        else
          container.bind_to mod.nil_var
        end

        bind_vars @vars, block.not_nil!.after_vars
      end

      @unreachable = true
    end

    def end_visit(node : Next)
      if block = @block
        block.bind_to(node.exp || mod.nil_var)

        bind_vars @vars, block.vars
        bind_vars @vars, block.after_vars
      elsif @while_stack.empty?
        node.raise "Invalid next"
      else
        bind_vars @vars, @while_vars
      end

      @unreachable = true
    end

    def visit(node : Primitive)
      case node.name
      when :binary
        visit_binary node
      when :cast
        visit_cast node
      when :allocate
        visit_allocate node
      when :pointer_malloc
        visit_pointer_malloc node
      when :pointer_set
        visit_pointer_set node
      when :pointer_get
        visit_pointer_get node
      when :pointer_address
        node.type = @mod.uint64
      when :pointer_new
        visit_pointer_new node
      when :pointer_realloc
        node.type = scope
      when :pointer_add
        node.type = scope
      when :argc
        node.type = @mod.int32
      when :argv
        node.type = @mod.pointer_of(@mod.pointer_of(@mod.uint8))
      when :struct_new
        node.type = scope.instance_type
      when :struct_set
        node.bind_to @vars["value"]
      when :struct_get
        visit_struct_get node
      when :union_new
        node.type = scope.instance_type
      when :union_set
        node.bind_to @vars["value"]
      when :union_get
        visit_union_get node
      when :external_var_set
        # Nothing to do
      when :external_var_get
        # Nothing to do
      when :object_id
        node.type = mod.uint64
      when :object_crystal_type_id
        node.type = mod.int32
      when :symbol_hash
        node.type = mod.int32
      when :symbol_to_s
        node.type = mod.string
      when :class
        node.type = scope.metaclass
      when :fun_call, :fun_closure?, :fun_pointer
        # Nothing to do
      when :pointer_diff
        node.type = mod.int64
      when :class_name
        node.type = mod.string
      when :enum_value
        # Nothing to do
      when :enum_new
        # Nothing to do
      else
        node.raise "Bug: unhandled primitive in type inference: #{node.name}"
      end
    end

    def visit_binary(node)
      case typed_def.name
      when "+", "-", "*", "/", "unsafe_div"
        t1 = scope
        t2 = typed_def.args[0].type
        node.type = t1.integer? && t2.float? ? t2 : t1
      when "==", "<", "<=", ">", ">=", "!="
        node.type = @mod.bool
      when "%", "<<", ">>", "|", "&", "^", "unsafe_mod"
        node.type = scope
      else
        raise "Bug: unknown binary operator #{typed_def.name}"
      end
    end

    def visit_cast(node)
      node.type =
        case typed_def.name
        when "to_i", "to_i32", "ord" then mod.int32
        when "to_i8" then mod.int8
        when "to_i16" then mod.int16
        when "to_i32" then mod.int32
        when "to_i64" then mod.int64
        when "to_u", "to_u32" then mod.uint32
        when "to_u8" then mod.uint8
        when "to_u16" then mod.uint16
        when "to_u32" then mod.uint32
        when "to_u64" then mod.uint64
        when "to_f", "to_f64" then mod.float64
        when "to_f32" then mod.float32
        when "chr" then mod.char
        else
          raise "Bug: unkown cast operator #{typed_def.name}"
        end
    end

    def visit_allocate(node)
      instance_type = scope.instance_type

      if instance_type.is_a?(GenericClassType)
        node.raise "can't create instance of generic class #{instance_type} without specifying its type vars"
      end

      if !instance_type.virtual? && instance_type.abstract
        node.raise "can't instantiate abstract #{instance_type.type_desc} #{instance_type}"
      end

      instance_type.allocated = true
      node.type = instance_type
    end

    def visit_pointer_malloc(node)
      if scope.instance_type.is_a?(GenericClassType)
        node.raise "can't malloc pointer without type, use Pointer(Type).malloc(size)"
      end

      node.type = scope.instance_type
    end

    def visit_pointer_set(node)
      scope = scope().remove_typedef as PointerInstanceType

      value = @vars["value"]

      scope.var.bind_to value
      node.bind_to value
    end

    def visit_pointer_get(node)
      scope = scope().remove_typedef as PointerInstanceType

      node.bind_to scope.var
    end

    def visit_pointer_new(node)
      if scope.instance_type.is_a?(GenericClassType)
        node.raise "can't create pointer without type, use Pointer(Type).new(address)"
      end

      node.type = scope.instance_type
    end

    def visit_struct_get(node)
      scope = @scope as CStructType
      node.bind_to scope.vars[untyped_def.name]
    end

    def visit_union_get(node)
      scope = @scope as CUnionType
      node.bind_to scope.vars[untyped_def.name]
    end

    def visit(node : Self)
      node.type = scope.instance_type
    end

    def visit(node : PointerOf)
      var = case node_exp = node.exp
            when Var
              meta_var = @meta_vars[node_exp.name]
              meta_var.assigned_to = true
              meta_var
            when InstanceVar
              lookup_instance_var node_exp
            when Path
              node_exp.accept self
              if const = node_exp.target_const
                const.value
              else
                node_exp.raise "can't take address of #{node_exp}"
              end
            else
              node_exp.raise "can't take address of #{node_exp}"
            end
      node.bind_to var
    end

    def visit(node : TypeOf)
      node.in_type_args = @in_type_args > 0

      old_in_type_args = @in_type_args
      @in_type_args = 0

      @typeof_nest += 1
      node.expressions.each &.accept self
      @typeof_nest -= 1

      @in_type_args = old_in_type_args

      node.bind_to node.expressions

      false
    end

    def end_visit(node : SizeOf)
      node.type = @mod.int32
    end

    def end_visit(node : InstanceSizeOf)
      node.type = @mod.int32
    end

    def visit(node : Rescue)
      if node_types = node.types
        types = node_types.map do |type|
          type.accept self
          instance_type = type.type.instance_type
          unless instance_type.is_subclass_of?(@mod.exception)
            type.raise "#{type} is not a subclass of Exception"
          end
          instance_type
        end
      end

      if node_name = node.name
        var = @vars[node_name] = new_meta_var(node_name)
        meta_var = @meta_vars[node_name] = new_meta_var(node_name)
        meta_var.bind_to(var)

        if types
          unified_type = @mod.type_merge(types).not_nil!
          unified_type = unified_type.virtual_type unless unified_type.is_a?(VirtualType)
        else
          unified_type = @mod.exception.virtual_type
        end
        var.set_type(unified_type)
        var.freeze_type = unified_type

        node.set_type(var.type)
      end

      node.body.accept self

      false
    end

    def visit(node : ExceptionHandler)
      old_exception_handler_vars = @exception_handler_vars

      # Save old vars to know if new variables are declared inside begin/rescue/else
      before_body_vars = @vars.dup

      # Any variable assigned in the body (begin) will have, inside rescue/else
      # blocks, all types that were assigned to them, because we can't know at which
      # point an exception is raised.
      exception_handler_vars = @exception_handler_vars = @vars.dup

      node.body.accept self

      @exception_handler_vars = nil

      if node.rescues || node.else
        # Any variable introduced in the begin block is possibly nil
        # in the rescue/else blocks because we can't know if an exception
        # was raised before assigning any of the vars.
        exception_handler_vars.each do |name, var|
          unless before_body_vars[name]?
            var.nil_if_read = true
          end
        end

        # Now, using these vars, visit all rescue/else blocks and keep
        # the results in this variable.
        all_rescue_vars = [] of MetaVars

        node.rescues.try &.each do |a_rescue|
          @vars = exception_handler_vars.dup
          @unreachable = false
          a_rescue.accept self
          all_rescue_vars << @vars unless @unreachable
        end

        node.else.try do |a_else|
          @vars = exception_handler_vars.dup
          @unreachable = false
          a_else.accept self
          all_rescue_vars << @vars unless @unreachable
        end

        # If all rescue/else blocks are unreachable, then afterwards
        # the flow continues as if there were no rescue/else blocks.
        if all_rescue_vars.empty?
          all_rescue_vars = nil
        else
          # Otherwise, merge all types that resulted from all rescue/else blocks
          merge_rescue_vars exception_handler_vars, all_rescue_vars

          # And then accept the ensure part
          node.ensure.try &.accept self
        end
      end

      # If there were no rescue/else blocks or all of them were unreachable
      unless all_rescue_vars
        if node_ensure = node.ensure
          after_handler_vars = @vars
          @vars = exception_handler_vars

          # Variables in the ensure block might be nil because we don't know
          # if an exception was thrown before any assignment.
          @vars.each do |name, var|
            unless before_body_vars[name]?
              var.nil_if_read = true
            end
          end

          node_ensure.accept self

          @vars = after_handler_vars
        end

        # However, those previous variables can't be nil afterwards:
        # if an exception was raised then we won't running the code
        # after the ensure clause, so variables don't matter. But if
        # an exception was not raised then all variables were declared
        # successfuly.
        @vars.each do |name, var|
          unless before_body_vars[name]?
            var.nil_if_read = false
          end
        end
      end

      if node_else = node.else
        node.bind_to node_else
      else
        node.bind_to node.body
      end

      if node_rescues = node.rescues
        node_rescues.each do |a_rescue|
          node.bind_to a_rescue.body
        end
      end

      old_exception_handler_vars = @exception_handler_vars

      false
    end

    def merge_rescue_vars(body_vars, all_rescue_vars)
      after_vars = MetaVars.new

      all_rescue_vars.each do |rescue_vars|
        rescue_vars.each do |name, var|
          after_var = (after_vars[name] ||= new_meta_var(name))
          if var.nil_if_read || !body_vars[name]?
            after_var.nil_if_read = true
          end
          after_var.bind_to(var)
        end
      end

      body_vars.each do |name, var|
        after_var = (after_vars[name] ||= new_meta_var(name))
        after_var.bind_to(var)
      end

      @vars = after_vars
    end

    def end_visit(node : TupleLiteral)
      node.elements.each &.add_observer(node)
      node.mod = @mod
      node.update
      false
    end

    def visit(node : TupleIndexer)
      node.type = (scope as TupleInstanceType).tuple_types[node.index] as Type
      false
    end

    def visit(node : VisibilityModifier)
      node.exp.visibility = node.modifier
      node.exp.accept self

      # Can only apply visibility modifier to def or a macro call
      case exp = node.exp
      when Def
        return false
      when Call
        if exp.expanded
          return false
        end
      end

      node.raise "can't apply visibility modifier"
    end

    def include_in(current_type, node, kind)
      node_name = node.name
      type = lookup_path_type(node_name)

      unless type.module?
        node_name.raise "#{node_name} is not a module, it's a #{type.type_desc}"
      end

      if node_name.is_a?(Generic)
        unless type.is_a?(GenericModuleType)
          node_name.raise "#{type} is not a generic module"
        end

        if type.type_vars.length != node_name.type_vars.length
          node_name.raise "wrong number of type vars for #{type} (#{node_name.type_vars.length} for #{type.type_vars.length})"
        end

        mapping = Hash.zip(type.type_vars, node_name.type_vars)
        module_to_include = IncludedGenericModule.new(@mod, type, current_type, mapping)
      else
        if type.is_a?(GenericModuleType)
          if current_type.is_a?(GenericType)
            current_type_type_vars_length = current_type.type_vars.length
            if current_type_type_vars_length != type.type_vars.length
              node_name.raise "#{type} wrong number of type vars for #{type} (#{current_type_type_vars_length} for #{current_type.type_vars.length})"
            end

            mapping = {} of String => ASTNode
            type.type_vars.zip(current_type.type_vars) do |type_var, current_type_var|
              mapping[type_var] = Path.new(current_type_var)
            end
            module_to_include = IncludedGenericModule.new(@mod, type, current_type, mapping)
          else
            node_name.raise "#{type} is a generic module"
          end
        else
          module_to_include = type
        end
      end

      begin
        current_type.include module_to_include
        run_hooks type.metaclass, current_type, kind, node
      rescue ex
        node_name.raise ex.message
      end
    end

    def process_struct_or_union_def(node, klass)
      type = current_type.types[node.name]?
      if type
        yield type
        type = type as CStructOrUnionType
        unless type.vars.empty?
          node.raise "#{node.name} is already defined"
        end
      else
        type = current_type.types[node.name] = klass.new @mod, current_type, node.name
      end

      pushing_type(type) do
        fields = node.fields.map do |field|
          field.accept self
          field_type = check_primitive_like field.restriction.not_nil!
          Var.new(field.name, field_type)
        end
        type.vars = fields
      end
    end

    def check_valid_attributes(node, valid_attributes, desc)
      if attributes = @attributes
        attributes.each do |attr|
          unless valid_attributes.includes?(attr.name)
            attr.raise "illegal attribute for #{desc}, valid attributes are: #{valid_attributes.join ", "}"
          end

          if !attr.args.empty? || attr.named_args
            attr.raise "#{attr.name} attribute can't receive arguments"
          end
        end
        node.attributes = attributes
      end
    end

    def attributes_doc
      @attributes.try(&.first?).try &.doc
    end

    def process_type_name(node_name)
      if node_name.names.length == 1 && !node_name.global
        scope = current_type
        name = node_name.names.first
      else
        name = node_name.names.pop
        scope = lookup_path_type node_name, create_modules_if_missing: true
      end
      {scope, name}
    end

    def lookup_path_type(node : Self, create_modules_if_missing = false)
      current_type
    end

    def lookup_path_type(node : Path, create_modules_if_missing = false)
      target_type = resolve_ident(node, create_modules_if_missing)
      if target_type.is_a?(Type)
        target_type.remove_alias_if_simple
      else
        node.raise "#{node} must be a type here, not #{target_type}"
      end
    end

    def lookup_path_type(node : Generic, create_modules_if_missing = false)
      lookup_path_type node.name, create_modules_if_missing
    end

    def lookup_path_type(node, create_modules_if_missing = false)
      raise "lookup_path_type not implemented for #{node}"
    end

    def resolve_ident(node : Path, create_modules_if_missing = false)
      free_vars = @free_vars
      if free_vars && !node.global && (type = free_vars[node.names.first]?)
        target_type = type
        if node.names.length > 1
          target_type = target_type.lookup_type(node.names[1 .. -1])
        end
      else
        base_lookup = node.global ? mod : (@type_lookup || @scope || @types.last)
        target_type = base_lookup.lookup_type node

        unless target_type
          if create_modules_if_missing
            next_type = base_lookup
            node.names.each do |name|
              next_type = base_lookup.lookup_type([name])
              if next_type
                if next_type.is_a?(ASTNode)
                  node.raise "execpted #{name} to be a type"
                end
              else
                next_type = NonGenericModuleType.new(@mod, base_lookup, name)

                if @mod.wants_doc? && (location = node.location)
                  next_type.locations << location
                end

                base_lookup.types[name] = next_type
              end
              base_lookup = next_type
            end
            target_type = next_type
          else
            similar_name = base_lookup.lookup_similar_type_name(node)
          end
        end
      end

      unless target_type
        error_msg = String.build do |msg|
          msg << "undefined constant #{node}"
          msg << " (did you mean '#{similar_name}'?)".colorize.yellow.bold if similar_name
        end
        node.raise error_msg
      end

      target_type
    end

    def check_primitive_like(node)
      type = node.type.instance_type
      unless type.primitive_like?
        msg = String.build do |msg|
          msg << "only primitive types, pointers, structs, unions and enums are allowed in lib declarations"
          msg << " (did you mean Int32?)" if type == @mod.int
          msg << " (did you mean Float32?)" if type == @mod.float
        end
        node.raise msg
      end

      if type.is_a?(TypeDefType) && type.typedef.fun?
        type = type.typedef
      end

      type
    end

    ## Literals

    def visit(node : Nop)
      node.type = @mod.nil
    end

    def visit(node : NilLiteral)
      node.type = @mod.nil
    end

    def visit(node : BoolLiteral)
      node.type = mod.bool
    end

    def visit(node : NumberLiteral)
      node.type = case node.kind
                  when :i8 then mod.int8
                  when :i16 then mod.int16
                  when :i32 then mod.int32
                  when :i64 then mod.int64
                  when :u8 then mod.uint8
                  when :u16 then mod.uint16
                  when :u32 then mod.uint32
                  when :u64 then mod.uint64
                  when :f32 then mod.float32
                  when :f64 then mod.float64
                  else raise "Invalid node kind: #{node.kind}"
                  end
    end

    def visit(node : CharLiteral)
      node.type = mod.char
    end

    def visit(node : SymbolLiteral)
      node.type = mod.symbol
      mod.symbols.add node.value
    end

    def visit(node : StringLiteral)
      node.type = mod.string
    end


    def visit(node : RegexLiteral)
      expand(node)
    end

    def visit(node : ArrayLiteral)
      if name = node.name
        name.accept self
        type = name.type.instance_type

        case type
        when GenericClassType
          type_name = type.name.split "::"

          path = Path.global(type_name).at(node.location)
          type_of = TypeOf.new(node.elements).at(node.location)
          generic = Generic.new(path, type_of).at(node.location)

          node.name = generic
        when GenericClassInstanceType
          # Nothing
        else
          type_name = type.to_s.split "::"
          path = Path.global(type_name).at(node.location)
          node.name = path
        end

        expand_named(node)
      else
        expand(node)
      end
    end

    def visit(node : HashLiteral)
      if name = node.name
        name.accept self
        type = name.type.instance_type

        case type
        when GenericClassType
          type_name = type.name.split "::"

          path = Path.global(type_name).at(node.location)
          type_of_keys = TypeOf.new(node.entries.map &.key).at(node.location)
          type_of_values = TypeOf.new(node.entries.map &.value).at(node.location)
          generic = Generic.new(path, [type_of_keys, type_of_values] of ASTNode).at(node.location)

          node.name = generic
        when GenericClassInstanceType
          # Nothing
        else
          type_name = type.to_s.split "::"

          path = Path.global(type_name).at(node.location)

          node.name = path
        end

        expand_named(node)
      else
        expand(node)
      end
    end

    def expand(node)
      expand(node) { @mod.literal_expander.expand node }
    end

    def expand_named(node)
      expand(node) { @mod.literal_expander.expand_named node  }
    end

    def expand(node)
      expanded = yield
      expanded.accept self
      node.expanded = expanded
      node.bind_to expanded
      false
    end

    ## Helpers

    def current_type
      @types.last
    end

    def check_closured(var)
      return if @typeof_nest > 0

      if var.name == "self"
        check_self_closured
        return
      end

      context = current_context
      var_context = var.context
      if !var_context.same?(context)
        # If the contexts are not the same, it might be that we are in a block
        # inside a method, or a block inside another block. We don't want
        # those cases to closure a variable. So if any context is a block
        # we go to the block's context (a def or a fun literal) and compare
        # if those are the same to determine whether the variable is closured.
        context = context.context if context.is_a?(Block)
        var_context = var_context.context if var_context.is_a?(Block)

        closured = !context.same?(var_context)
        if closured
          var.closured = true

          # Go up and mark fun literal defs as closured until we get
          # to the context where the variable is defined
          visitor = self
          while visitor
            visitor_context = visitor.closure_context
            break if visitor_context == var_context

            visitor_context.closure = true if visitor_context.is_a?(Def)
            visitor = visitor.parent
          end
        end
      end
    end

    def check_self_closured
      if (context = @fun_literal_context) && context.is_a?(Def)
        context.self_closured = true

        # Go up and mark fun literal defs as closured until the top
        # (which should be when we leave the top Def)
        visitor = self
        while visitor
          visitor_context = visitor.closure_context
          visitor_context.closure = true if visitor_context.is_a?(Def)
          visitor = visitor.parent
        end
      end
    end

    def current_context
      @block_context || current_non_block_context
    end

    def current_non_block_context
      @typed_def || @mod
    end

    def closure_context
      context = current_context
      context = context.context if context.is_a?(Block)
      context
    end

    def lookup_var_or_instance_var(var : Var)
      @vars[var.name]
    end

    def lookup_var_or_instance_var(var : InstanceVar)
      scope = @scope as InstanceVarContainer
      scope.lookup_instance_var(var.name)
    end

    def lookup_var_or_instance_var(var)
      raise "Bug: trying to lookup var or instance var but got #{var}"
    end

    def bind_meta_var(var : Var)
      @meta_vars[var.name].bind_to(var)
    end

    def bind_meta_var(var : InstanceVar)
      # Nothing to do
    end

    def bind_meta_var(var)
      raise "Bug: trying to bind var or instance var but got #{var}"
    end

    def bind_initialize_instance_vars(owner)
      names_to_remove = [] of String

      @vars.each do |name, var|
        if name.starts_with? '@'
          if var.nil_if_read
            ivar = owner.lookup_instance_var(name)
            ivar.bind_to @mod.nil_var
          end

          names_to_remove << name
        end
      end

      names_to_remove.each do |name|
        @meta_vars.delete name
        @vars.delete name
      end
    end

    def needs_type_filters?
      @needs_type_filters > 0
    end

    def request_type_filters
      @type_filters = nil
      @needs_type_filters += 1
      begin
        yield
      ensure
        @needs_type_filters -= 1
      end
    end

    def ignoring_type_filters
      needs_type_filters, @needs_type_filters = @needs_type_filters, 0
      begin
        yield
      ensure
        @needs_type_filters = needs_type_filters
      end
    end

    def lookup_similar_var_name(name)
      SimilarName.find(name) do |similar_name|
        @meta_vars.each_key do |var_name|
          similar_name.test(var_name)
        end
      end
    end

    def new_meta_var(name, context = current_context)
      meta_var = MetaVar.new(name)
      meta_var.context = context
      meta_var
    end

    def block=(@block)
      @block_context = @block
    end

    def inside_block?
      @block_context
    end

    def pushing_type(type)
      @types.push type
      yield
      @types.pop
    end

    def visit(node : And | Or | Require | RangeLiteral | Case |
                     When | Unless | StringInterpolation | MultiAssign |
                     Until | MacroLiteral)
      raise "Bug: #{node.class_desc} node '#{node}' (#{node.location}) should have been eliminated in normalize"
    end
  end
end
