require "../program"
require "../syntax/ast"
require "../syntax/visitor"
require "./*"

module Crystal
  class Program
    def infer_type(node)
      result = infer_type_intermediate(node)
      finish_types
      result
    end

    def infer_type_intermediate(node)
      node.accept TypeVisitor.new(self)
      expand_macro_defs
      fix_empty_types node
      after_type_inference node
    end
  end

  class TypeVisitor < Visitor
    ThreadLocalAttributes = %w(ThreadLocal)
    ValidGlobalAttributes = ThreadLocalAttributes
    ValidExternalVarAttributes = ThreadLocalAttributes
    ValidClassVarAttributes = ThreadLocalAttributes
    ValidStructDefAttributes = %w(Packed)
    ValidDefAttributes = %w(AlwaysInline NoInline Raises ReturnsTwice)
    ValidFunDefAttributes = %w(AlwaysInline NoInline Raises ReturnsTwice CallConvention)
    ValidEnumDefAttributes = %w(Flags)

    getter mod
    property! scope
    getter! typed_def
    property! untyped_def
    getter block
    property call
    property type_lookup
    property fun_literal_context
    property parent
    property types
    property block_nest
    property with_scope

    # These are the free variables that came from matches. We look up
    # here first if we find a single-element Path like `T`.
    property free_vars

    # These are the variables and types that come from a block specification
    # like `&block : Int32 -> Int32`. When doing `yield 1` we need to verify
    # that the yielded expression has the type that the block specification said.
    property yield_vars

    # In vars we store the types of variables as we traverse the nodes.
    # These type are not cummulative: if you do `x = 1`, 'x' will have
    # type Int32. Then if you do `x = false`, 'x' will have type Bool.
    getter vars

    # Here we store the cummulative types of variables as we traverse the nodes.
    getter meta_vars

    getter is_initialize

    @unreachable = false
    @is_initialize = false

    def initialize(@mod, vars = MetaVars.new, @typed_def = nil, meta_vars = nil)
      @types = [@mod] of Type
      @while_stack = [] of While
      @vars = vars
      @needs_type_filters = 0
      @unreachable = false
      @block_nest = 0
      @typeof_nest = 0
      @is_initialize = !!(typed_def && typed_def.name == "initialize")
      @found_self_in_initialize_call = nil
      @used_ivars_in_calls_in_initialize = nil
      @in_type_args = 0
      @in_is_a = false
      @attributes  = nil
      @lib_def_pass = 0
      @exp_nest = 0

      # We initialize meta_vars from vars given in the constructor.
      # We store those meta vars either in the typed def or in the program
      # so the codegen phase knows the cummulative types to do allocas.
      unless meta_vars
        if typed_def = @typed_def
          meta_vars = typed_def.vars = MetaVars.new
        else
          meta_vars = @mod.vars
        end
        vars.each do |name, var|
          meta_var = new_meta_var(name)
          meta_var.bind_to(var)
          meta_vars[name] = meta_var
        end
      end

      @meta_vars = meta_vars
    end

    def visit(node : ASTNode)
      true
    end

    def visit(node : Attribute)
      attributes = @attributes ||= [] of Attribute
      attributes << node
      false
    end

    def visit_any(node)
      @unreachable = false
      @exp_nest += 1 if nesting_exp?(node)

      true
    end

    def end_visit_any(node)
      @exp_nest -= 1 if nesting_exp?(node)

      if @attributes
        case node
        when Expressions
          # Nothing, will be taken care in individual expressions
        when Attribute
          # Nothing
        when Nop
          # Nothing (might happen as a result of an evaulated ifdef)
        when Call
          # Don't clear attributes if these were generated by a macro
          unless node.expanded
            @attributes = nil
          end
        else
          @attributes = nil
        end
      end
    end

    def nesting_exp?(node)
      case node
      when Expressions, LibDef, ClassDef, ModuleDef, FunDef, Def, Macro,
           Alias, Include, Extend, EnumDef, VisibilityModifier, MacroFor, MacroIf, MacroExpression
        false
      else
        true
      end
    end

    def visit(node : Var)
      var = @vars[node.name]?
      if var
        meta_var = @meta_vars[node.name]
        check_closured meta_var

        if var.nil_if_read
          meta_var.bind_to(@mod.nil_var) unless meta_var.dependencies.try &.any? &.same?(@mod.nil_var)
          node.bind_to(@mod.nil_var)
        end

        if meta_var.closured
          var.bind_to(meta_var)
        end

        node.bind_to(var)

        if needs_type_filters?
          @type_filters = TypeFilters.truthy(node)
        end
      elsif node.name == "self"
        current_type = current_type()
        if current_type.is_a?(Program)
          node.raise "there's no self in this scope"
        else
          node.type = current_type.metaclass
        end
      elsif node.special_var?
        special_var = define_special_var(node.name, mod.nil_var)
        node.bind_to special_var
      else
        node.raise "read before definition of '#{node.name}'"
      end
    end

    def visit(node : DeclareVar)
      case var = node.var
      when Var
        if @vars[var.name]?
          var.raise "variable '#{var.name}' already declared"
        end

        node.declared_type.accept self
        node.type = check_declare_var_type node

        var.bind_to node

        meta_var = @meta_vars[var.name] ||= new_meta_var(var.name)
        if (existing_type = meta_var.type?) && existing_type != node.type
          node.raise "variable '#{var.name}' already declared with type #{existing_type}"
        end

        meta_var.bind_to(var)
        meta_var.freeze_type = node.type

        @vars[var.name] = meta_var

        check_exception_handler_vars(var.name, node)
      when InstanceVar
        type = scope? || current_type
        if @untyped_def
          node.declared_type.accept self
          node.type = check_declare_var_type node
          ivar = lookup_instance_var var
          ivar.bind_to node
          var.bind_to node

          if @is_initialize
            @vars[var.name] = MetaVar.new(var.name, node.type)
          end
        end

        case type
        when NonGenericClassType
          node.declared_type.accept self
          node.type = check_declare_var_type node
          type.declare_instance_var(var.name, node.type)
        when GenericClassType
          type.declare_instance_var(var.name, node.declared_type)
        when GenericClassInstanceType
          # OK
        else
          node.raise "can only declare instance variables of a non-generic class, not a #{type.type_desc} (#{type})"
        end
      end

      false
    end

    def check_exception_handler_vars(var_name, node)
      # If inside a begin part of an exception handler, bind this type to
      # the variable that will be used in the rescue/else blocks.
      if exception_handler_vars = @exception_handler_vars
        var = (exception_handler_vars[var_name] ||= MetaVar.new(var_name))
        var.bind_to(node)
      end
    end

    def visit(node : Out)
      case exp = node.exp
      when Var
        if @meta_vars.has_key?(exp.name)
          exp.raise "variable '#{exp.name}' is already defined, `out` must be used to define a variable, use another name"
        end

        # We declare out variables
        @meta_vars[exp.name] = new_meta_var(exp.name)
        @vars[exp.name] = new_meta_var(exp.name)
      when InstanceVar
        var = lookup_instance_var exp
        exp.bind_to(var)

        if @is_initialize
          @vars[exp.name] = MetaVar.new(exp.name)
        end
      when Underscore
        # Nothing to do
      else
        node.raise "Bug: unexpected out exp: #{exp}"
      end

      node.bind_to node.exp

      false
    end

    def check_declare_var_type(node)
      type = node.declared_type.type.instance_type

      if type.is_a?(GenericClassType)
        node.raise "can't declare variable of generic non-instantiated type #{type}"
      end

      Crystal.check_type_allowed_in_generics(node, type, "can't use #{type} as a Proc argument type")

      type
    end

    def visit(node : Global)
      visit_global node
      false
    end

    def visit_global(node)
      var = mod.global_vars[node.name]?
      unless var
        var = Var.new(node.name)
        var.bind_to mod.nil_var
        mod.global_vars[node.name] = var
      end
      node.bind_to var
      var
    end

    def visit(node : InstanceVar)
      var = lookup_instance_var node
      node.bind_to(var)

      if @is_initialize && !@vars.has_key? node.name
        ivar = scope.lookup_instance_var(node.name)
        ivar.nil_reason ||= NilReason.new(node.name, :used_before_initialized, [node] of ASTNode)
        ivar.bind_to mod.nil_var
      end
    end

    def visit(node : ReadInstanceVar)
      visit_read_instance_var node
      false
    end

    def visit_read_instance_var(node)
      node.obj.accept self

      obj_type = node.obj.type
      unless obj_type.is_a?(InstanceVarContainer)
        node.raise "#{obj_type} doesn't have instance vars"
      end

      ivar = obj_type.lookup_instance_var?(node.name, false)
      unless ivar
        node.raise "#{obj_type} doesn't have an instance var named '#{node.name}'"
      end

      node.bind_to ivar

      ivar
    end

    def visit(node : ClassVar)
      visit_class_var node
      false
    end

    def visit_class_var(node)
      class_var = lookup_class_var(node)
      check_valid_attributes class_var, ValidClassVarAttributes, "class variable"

      node.attributes = class_var.attributes
      node.bind_to class_var

      class_var
    end

    def lookup_instance_var(node)
      case scope = @scope.try &.remove_typedef
      when Nil
        node.raise "can't use instance variables at the top level"
      when Program
        node.raise "can't use instance variables at the top level"
      when PrimitiveType
        node.raise "can't use instance variables inside primitive types (at #{scope})"
      when EnumType
        node.raise "can't use instance variables inside enums (at enum #{scope})"
      when .metaclass?
        node.raise "@instance_vars are not yet allowed in metaclasses: use @@class_vars instead"
      when InstanceVarContainer
        var = scope.lookup_instance_var node.name
        unless scope.has_instance_var_in_initialize?(node.name)
          var.nil_reason = NilReason.new(node.name, :not_in_initialize, scope: scope)
          var.bind_to mod.nil_var
        end
        check_self_closured
        var
      else
        node.raise "Bug: #{scope} is not an InstanceVarContainer"
      end
    end

    def lookup_class_var(node, bind_to_nil_if_non_existent = true)
      scope = (@scope || current_type).class_var_owner
      if scope.is_a?(GenericClassType) || scope.is_a?(GenericModuleType)
        node.raise "can't use class variable with generic types, only with generic types instances"
      end

      class_var_owner = scope as ClassVarContainer

      bind_to_nil = bind_to_nil_if_non_existent && !class_var_owner.has_class_var?(node.name)

      var = class_var_owner.lookup_class_var node.name
      var.bind_to mod.nil_var if bind_to_nil

      node.owner = class_var_owner
      node.var = var
      node.class_scope = !@typed_def

      var
    end

    def end_visit(node : Expressions)
      node.bind_to node.last unless node.empty?
    end

    def visit(node : Assign)
      type_assign node.target, node.value, node

      if @is_initialize && !@found_self_in_initialize_call
        value = node.value
        if value.is_a?(Var) && value.name == "self"
          @found_self_in_initialize_call = [value] of ASTNode
        end
      end
      false
    end

    def type_assign(target : Var, value, node)
      value.accept self

      target.bind_to value
      node.bind_to value

      var_name = target.name

      value_type_filters = @type_filters
      @type_filters = nil

      meta_var = (@meta_vars[var_name] ||= new_meta_var(var_name))

      begin
        meta_var.bind_to value
      rescue ex : FrozenTypeException
        target.raise ex.message
      end

      meta_var.assigned_to = true
      check_closured meta_var

      simple_var = MetaVar.new(var_name)
      simple_var.bind_to(target)

      if meta_var.closured
        simple_var.bind_to(meta_var)
      end

      @vars[var_name] = simple_var

      check_exception_handler_vars var_name, value

      if needs_type_filters?
        @type_filters = TypeFilters.and(TypeFilters.truthy(target), value_type_filters)
      end

      if target.special_var?
        if typed_def = @typed_def
          typed_def.add_special_var(target.name)

          # If we are in a call's block, define the special var in the block
          if (call = @call) && call.block
            call.parent_visitor.define_special_var(target.name, value)
          end
        else
          node.raise "'#{var_name}' can't be assigned at the top level"
        end
      end
    end

    def type_assign(target : InstanceVar, value, node)
      # Check if this is an instance variable initializer
      unless @scope
        current_type = current_type()
        if current_type.is_a?(ClassType)
          @mod.after_inference_types << current_type

          ivar_visitor = TypeVisitor.new(mod)
          ivar_visitor.scope = current_type

          unless current_type.is_a?(GenericType)
            value.accept ivar_visitor
          end

          current_type.add_instance_var_initializer(target.name, value, ivar_visitor.meta_vars)
          if current_type.is_a?(GenericType)
            node.type = @mod.nil
            return
          else
            var = current_type.lookup_instance_var(target.name, true)
          end
        end
      end

      unless var
        value.accept self
        var = lookup_instance_var target
      end

      target.bind_to var
      node.bind_to value

      begin
        var.bind_to node
      rescue ex : FrozenTypeException
        target.raise ex.message
      end

      if @is_initialize
        var_name = target.name

        meta_var = (@meta_vars[var_name] ||= new_meta_var(var_name))
        meta_var.bind_to value
        meta_var.assigned_to = true

        simple_var = MetaVar.new(var_name)
        simple_var.bind_to(target)

        used_ivars_in_calls_in_initialize = @used_ivars_in_calls_in_initialize
        if (found_self = @found_self_in_initialize_call) || (used_ivars_node = used_ivars_in_calls_in_initialize.try(&.[var_name]?)) || (@block_nest > 0 && !@vars.has_key?(var_name))
          ivar = scope.lookup_instance_var(var_name)
          if found_self
            ivar.nil_reason = NilReason.new(var_name, :used_self_before_initialized, found_self)
          else
            ivar.nil_reason = NilReason.new(var_name, :used_before_initialized, used_ivars_node)
          end
          ivar.bind_to mod.nil_var
        end

        @vars[var_name] = simple_var
      end
    end

    def type_assign(target : Path, value, node)
      return if @lib_def_pass == 2

      type = current_type.types[target.names.first]?
      if type
        target.raise "already initialized constant #{type}"
      end

      target.bind_to value

      const = Const.new(@mod, current_type, target.names.first, value, @types.dup, @scope)
      attach_doc const, node

      current_type.types[target.names.first] = const

      node.type = @mod.nil
      target.target_const = const
    end

    def type_assign(target : Global, value, node)
      check_valid_attributes target, ValidGlobalAttributes, "global variable"

      value.accept self

      var = mod.global_vars[target.name]?
      unless var
        var = Var.new(target.name)
        if @typed_def
          var.bind_to mod.nil_var
        end
        mod.global_vars[target.name] = var
      end
      var.add_attributes(target.attributes)

      target.bind_to var

      node.bind_to value
      var.bind_to node
    end

    def type_assign(target : ClassVar, value, node)
      var = lookup_class_var target, !!@typed_def
      check_valid_attributes var, ValidClassVarAttributes, "class variable"

      value.accept self

      target.attributes = var.attributes
      target.bind_to var

      node.bind_to value
      var.bind_to node
    end

    def type_assign(target : Underscore, value, node)
      value.accept self
      node.bind_to value
    end

    def type_assign(target, value, node)
      raise "Bug: unknown assign target in type inference: #{target}"
    end

    def visit(node : Def)
      check_outside_block_or_exp node, "declare def"

      check_valid_attributes node, ValidDefAttributes, "def"
      node.doc ||= attributes_doc()
      check_ditto node

      target_type = case receiver = node.receiver
                    when Nil
                      current_type
                    when Var
                      unless receiver.name == "self"
                        receiver.raise "def receiver can only be a Type or self"
                      end
                      current_type.metaclass
                    else
                      type = lookup_path_type(receiver).metaclass
                      node.raise "can't define 'def' for lib" if type.is_a?(LibType)
                      type
                    end

      node.raises = true if node.has_attribute?("Raises")

      target_type.add_def node
      node.set_type @mod.nil
      false
    end

    def visit(node : Macro)
      check_outside_block_or_exp node, "declare macro"

      begin
        current_type.metaclass.add_macro node
      rescue ex : Crystal::Exception
        node.raise ex.message
      end

      node.set_type @mod.nil
      false
    end

    def visit(node : Yield)
      if @fun_literal_context
        node.raise "can't yield from function literal"
      end

      call = @call
      unless call
        node.raise "can't yield outside a method"
      end

      block = call.block || node.raise("no block given")

      # This is the case of a yield when there's a captured block
      if block.fun_literal
        block_arg_name = typed_def.block_arg.not_nil!.name
        block_var = Var.new(block_arg_name).at(node.location)
        call = Call.new(block_var, "call", node.exps).at(node.location)
        call.accept self
        node.bind_to call
        node.expanded = call
        return false
      end

      node.scope.try &.accept self
      node.exps.each &.accept self

      if (yield_vars = @yield_vars) && !node.scope
        yield_vars.each_with_index do |var, i|
          exp = node.exps[i]?
          if exp
            # TODO: this should really be var.type.implements?(exp.type)
            if (exp_type = exp.type?) && !exp_type.is_restriction_of?(var.type, exp_type)
              exp.raise "argument ##{i + 1} of yield expected to be #{var.type}, not #{exp_type}"
            end

            exp.freeze_type = var.type
          elsif !var.type.nil_type?
            node.raise "missing argument ##{i + 1} of yield with type #{var.type}"
          end
        end
      end

      bind_block_args_to_yield_exps block, node

      unless block.visited
        # When we yield, we are no longer inside `untyped_def`, so we un-nest
        untyped_def = @untyped_def
        untyped_def.block_nest -= 1 if untyped_def

        call.bubbling_exception do
          if node_scope = node.scope
            block.scope = node_scope.type
          end
          ignoring_type_filters do
            block.accept call.parent_visitor.not_nil!
          end
        end

        # And now we are back inside `untyped_def`
        untyped_def.block_nest += 1 if untyped_def
      end

      node.bind_to block

      @type_filters = nil
      false
    end

    # We bind yield exps -> typed_def.yield_vars -> block args
    # so when a call is recomputed we unbind the block args from the yield
    # vars (so old instantiations don't mess the final type)
    def bind_block_args_to_yield_exps(block, node)
      yield_vars = typed_def.yield_vars ||= block.args.map { |block| Var.new(block.name) }

      block.args.each_with_index do |arg, i|
        yield_var = yield_vars[i]
        yield_var.bind_to(node.exps[i]? || mod.nil_var)
        arg.bind_to(yield_var)
      end
    end

    def visit(node : Block)
      return if node.visited

      node.visited = true
      node.context = current_non_block_context

      before_block_vars = node.vars.try(&.dup) || MetaVars.new

      meta_vars = @meta_vars.dup
      node.args.each do |arg|
        meta_var = new_meta_var(arg.name, context: node)
        meta_var.bind_to(arg)
        meta_vars[arg.name] = meta_var

        before_block_var = new_meta_var(arg.name, context: node)
        before_block_var.bind_to(arg)
        before_block_vars[arg.name] = before_block_var
      end

      @block_nest += 1

      block_visitor = TypeVisitor.new(mod, before_block_vars, @typed_def, meta_vars)
      block_visitor.yield_vars = @yield_vars
      block_visitor.free_vars = @free_vars
      block_visitor.untyped_def = @untyped_def
      block_visitor.call = @call
      block_visitor.fun_literal_context = @fun_literal_context
      block_visitor.parent = self
      block_visitor.with_scope = node.scope || with_scope

      block_scope = @scope
      block_scope ||= current_type.metaclass unless current_type.is_a?(Program)

      block_visitor.scope = block_scope

      block_visitor.block = node
      block_visitor.type_lookup = type_lookup || current_type
      block_visitor.block_nest = @block_nest

      node.body.accept block_visitor

      @block_nest -= 1

      # Check re-assigned variables and bind them.
      bind_vars block_visitor.vars, node.vars
      bind_vars block_visitor.vars, node.after_vars, node.args

      # Special vars, even if only assigned inside a block,
      # must be inside the def's metavars.
      meta_vars.each do |name, var|
        if var.special_var?
          new_var = @meta_vars[name] ||= new_meta_var(name)
          new_var.bind_to(var)
        end
      end

      node.vars = meta_vars

      node.bind_to node.body

      false
    end

    def bind_vars(from_vars, to_vars, ignored = nil)
      if to_vars
        from_vars.each do |name, block_var|
          unless ignored.try &.find { |arg| arg.name == name }
            to_var = to_vars[name]?
            if to_var && !to_var.same?(block_var)
              to_var.try &.bind_to(block_var)
            end
          end
        end
      end
    end

    def visit(node : FunLiteral)
      return false if node.type?

      fun_vars = @vars.dup
      meta_vars = @meta_vars.dup

      node.def.args.each do |arg|
        # It can happen that the argument has a type already,
        # when converting a block to a fun literal
        if restriction = arg.restriction
          restriction.accept self
          arg_type = restriction.type.instance_type
          TypeVisitor.check_type_allowed_as_proc_argument(node, arg_type)
          arg.type = arg_type.virtual_type
        elsif !arg.type?
          arg.raise "function argument '#{arg.name}' must have a type"
        end

        fun_var = MetaVar.new(arg.name, arg.type)
        fun_vars[arg.name] = fun_var

        meta_var = new_meta_var(arg.name, context: node.def)
        meta_var.bind_to fun_var
        meta_vars[arg.name] = meta_var
      end

      node.bind_to node.def
      node.def.bind_to node.def.body
      node.def.vars = meta_vars

      block_visitor = TypeVisitor.new(mod, fun_vars, node.def, meta_vars)
      block_visitor.types = @types
      block_visitor.yield_vars = @yield_vars
      block_visitor.free_vars = @free_vars
      block_visitor.untyped_def = node.def
      block_visitor.call = @call
      block_visitor.scope = @scope
      block_visitor.type_lookup = type_lookup
      block_visitor.fun_literal_context = @fun_literal_context || @typed_def || @mod
      block_visitor.block_nest = @block_nest
      block_visitor.parent = self

      node.def.body.accept block_visitor

      false
    end

    def self.check_type_allowed_as_proc_argument(node, type)
      Crystal.check_type_allowed_in_generics(node, type, "cannot be used as a Proc argument type")
    end

    def visit(node : FunPointer)
      return false if node.call?

      obj = node.obj

      if obj
        obj.accept self
      end

      call = Call.new(obj, node.name)
      prepare_call(call)

      # Check if it's ->LibFoo.foo, so we deduce the type from that method
      if node.args.empty? && obj && (obj_type = obj.type).is_a?(LibType)
        matching_fun = obj_type.lookup_first_def(node.name, false)
        node.raise "undefined fun '#{node.name}' for #{obj_type}" unless matching_fun

        call.args = matching_fun.args.map_with_index do |arg, i|
          Var.new("arg#{i}", arg.type.instance_type) as ASTNode
        end
      else
        call.args = node.args.map_with_index do |arg, i|
          arg.accept self
          arg_type = arg.type.instance_type
          TypeVisitor.check_type_allowed_as_proc_argument(node, arg_type)
          Var.new("arg#{i}", arg_type.virtual_type) as ASTNode
        end
      end

      begin
        call.recalculate
      rescue ex : Crystal::Exception
        node.raise "error instantiating #{node}", ex
      end

      node.call = call
      node.bind_to call

      false
    end

    def end_visit(node : Fun)
      if inputs = node.inputs
        types = inputs.map &.type.instance_type.virtual_type
      else
        types = [] of Type
      end

      if output = node.output
        types << output.type.instance_type.virtual_type
      else
        types << mod.void
      end

      node.type = mod.fun_of(types)
    end

    def visit(node : Call)
      prepare_call(node)

      if expand_macro(node)
        return false
      end

      obj = node.obj
      args = node.args
      block_arg = node.block_arg
      named_args = node.named_args

      ignoring_type_filters do
        if obj
          obj.accept(self)

          check_lib_call node, obj.type?

          if check_special_new_call(node, obj.type?)
            return false
          end
        end

        args.each &.accept(self)
        block_arg.try &.accept self
        named_args.try &.each &.value.accept self
      end

      obj.try &.add_input_observer(node)
      args.each &.add_input_observer(node)
      block_arg.try &.add_input_observer node
      named_args.try &.each &.value.add_input_observer(node)

      check_super_in_initialize node

      # If the call has a block we need to create a copy of the variables
      # and bind them to the current variables. Then, when visiting
      # the block we will bind more variables to these ones if variables
      # are reassigned.
      if node.block || block_arg
        before_vars = MetaVars.new
        after_vars = MetaVars.new

        @vars.each do |name, var|
          before_var = MetaVar.new(name)
          before_var.bind_to(var)
          before_var.nil_if_read = var.nil_if_read
          before_vars[name] = before_var

          after_var = MetaVar.new(name)
          after_var.bind_to(var)
          after_var.nil_if_read = var.nil_if_read
          after_vars[name] = after_var
          @vars[name] = after_var
        end

        if block = node.block
          block.vars = before_vars
          block.after_vars = after_vars
        else
          node.before_vars = before_vars
        end
      end

      node.recalculate

      check_call_in_initialize node

      @type_filters = nil
      @unreachable = true if node.no_returns?

      false
    end

    def prepare_call(node)
      if node.global
        node.scope = @mod
      else
        node.scope = @scope || current_type.metaclass
      end
      node.with_scope = with_scope
      node.parent_visitor = self
    end

    # If it's a super call inside an initialize we treat
    # set instance vars from superclasses to not-nil
    def check_super_in_initialize(node)
      if @is_initialize && node.name == "super" && !node.obj
        superclass = scope.superclass

        while superclass
          superclass.instance_vars_in_initialize.try &.each do |name|
            instance_var = scope.lookup_instance_var(name)

            # But variables that were already used are nilable
            if @used_ivars_in_calls_in_initialize.try &.has_key?(name)
              instance_var.bind_to @mod.nil_var
            else
              meta_var = MetaVar.new(name)
              meta_var.bind_to instance_var
              @vars[name] = meta_var
            end
          end

          superclass = superclass.superclass
        end
      end
    end

    # Check if it's a call to self. In that case, all instance variables
    # not mentioned so far will be considered nil.
    def check_call_in_initialize(node)
      return unless @is_initialize
      return if @typeof_nest > 0

      node_obj = node.obj
      if !node_obj || (node_obj.is_a?(Var) && node_obj.name == "self")
        # Special case: when calling self.class a class method will be invoked
        # and there's no possibility of accessing instance vars, so we ignore this case.
        if node.name == "class" && node.args.empty?
          return
        end

        ivars, found_self = gather_instance_vars_read node
        if found_self
          @found_self_in_initialize_call ||= found_self
        elsif ivars
          used_ivars_in_calls_in_initialize = @used_ivars_in_calls_in_initialize
          if used_ivars_in_calls_in_initialize
            @used_ivars_in_calls_in_initialize = used_ivars_in_calls_in_initialize.merge(ivars)
          else
            @used_ivars_in_calls_in_initialize = ivars
          end
        end
      else
        # Check if any argument is "self"
        unless @found_self_in_initialize_call
          node.args.each do |arg|
            if arg.is_a?(Var) && arg.name == "self"
              @found_self_in_initialize_call = [node] of ASTNode
              return
            end
          end
        end
      end
    end

    # Fill function literal argument types for C functions
    def check_lib_call(node, obj_type)
      return unless obj_type.is_a?(LibType)

      method = nil

      node.args.each_with_index do |arg, index|
        case arg
        when FunLiteral
          next unless arg.def.args.any? { |def_arg| !def_arg.restriction && !def_arg.type? }

          method ||= obj_type.lookup_first_def(node.name, false)
          return unless method

          check_lib_call_arg(method, index) do |method_arg_type|
            arg.def.args.each_with_index do |def_arg, def_arg_index|
              if !def_arg.restriction && !def_arg.type?
                def_arg.type = method_arg_type.fun_types[def_arg_index]?
              end
            end
          end
        when FunPointer
          next unless arg.args.empty?

          method ||= obj_type.lookup_first_def(node.name, false)
          return unless method

          check_lib_call_arg(method, index) do |method_arg_type|
            method_arg_type.arg_types.each do |arg_type|
              arg.args.push TypeNode.new(arg_type)
            end
          end
        end
      end
    end

    def check_lib_call_arg(method, arg_index)
      method_arg = method.args[arg_index]?
      return unless method_arg

      method_arg_type = method_arg.type
      return unless method_arg_type.is_a?(FunInstanceType)

      yield method_arg_type
    end

    # Check if it's FunType#new
    def check_special_new_call(node, obj_type)
      return false unless obj_type
      return false unless obj_type.metaclass?

      instance_type = obj_type.instance_type.remove_typedef

      if node.name == "new"
        case instance_type
        when FunInstanceType
          return special_fun_type_new_call(node, instance_type)
        when CStructOrUnionType
          if named_args = node.named_args
            return special_struct_or_union_new_with_named_args(node, instance_type, named_args)
          end
        end
      end

      false
    end

    def special_fun_type_new_call(node, fun_type)
      if node.args.size != 0
        return false
      end

      block = node.block
      unless block
        return false
      end

      if block.args.size > fun_type.fun_types.size - 1
        node.raise "wrong number of block arguments for #{fun_type}#new (#{block.args.size} for #{fun_type.fun_types.size - 1})"
      end

      # We create a ->(...) { } from the block
      fun_args = fun_type.arg_types.map_with_index do |arg_type, index|
        block_arg = block.args[index]?
        Arg.new(block_arg.try(&.name) || @mod.new_temp_var_name, type: arg_type)
      end

      fun_def = Def.new("->", fun_args, block.body)
      fun_literal = FunLiteral.new(fun_def).at(node.location)
      fun_literal.expected_return_type = fun_type.return_type
      fun_literal.accept self

      node.bind_to fun_literal
      node.expanded = fun_literal

      true
    end

    # Rewrite:
    #
    #     LibFoo::Struct.new arg0: value0, argN: value0
    #
    # To:
    #
    #   temp = LibFoo::Struct.new
    #   temp.arg0 = value0
    #   temp.argN = valueN
    #   temp
    def special_struct_or_union_new_with_named_args(node, type, named_args)
      exps = [] of ASTNode

      temp_name = @mod.new_temp_var_name

      new_call = Call.new(node.obj, "new").at(node.location)

      new_assign = Assign.new(Var.new(temp_name), new_call)
      exps << new_assign

      named_args.each do |named_arg|
        assign_call = Call.new(Var.new(temp_name), "#{named_arg.name}=", named_arg.value)
        if loc = named_arg.location
          assign_call.location = loc
          assign_call.name_column_number = loc.column_number
        end
        exps << assign_call
      end

      exps << Var.new(temp_name)

      expanded = Expressions.new(exps)
      expanded.accept self

      node.bind_to expanded
      node.expanded = expanded

      true
    end

    class InstanceVarsCollector < Visitor
      getter ivars
      getter found_self

      def initialize(a_def, @scope, @vars)
        @found_self = nil
        @in_super = 0
        @callstack = [a_def] of ASTNode
      end

      def node_in_callstack(node)
        nodes = [] of ASTNode
        nodes.concat @callstack
        nodes.push node
        nodes
      end

      def visit(node : InstanceVar)
        unless @vars.has_key?(node.name)
          ivars = @ivars ||= Hash(String, Array(ASTNode)).new
          unless ivars.has_key?(node.name)
            ivars[node.name] = node_in_callstack(node)
          end
        end
      end

      def visit(node : Var)
        if @in_super == 0 && node.name == "self"
          @found_self = node_in_callstack(node)
        end
        false
      end

      def visit(node : Assign)
        node.value.accept self
        false
      end

      def visit(node : Call)
        obj = node.obj

        # Skip class method
        if obj.is_a?(Var) && obj.name == "self" && node.name == "class" && node.args.empty?
          return false
        end

        visited = @visited

        node.target_defs.try &.each do |target_def|
          if target_def.owner == @scope
            next if visited.try &.includes?(target_def.object_id)

            visited = @visited ||= Set(typeof(object_id)).new
            visited << target_def.object_id

            @callstack.push(node)
            target_def.body.accept self
            @callstack.pop
          end
        end

        if node.name == "super"
          @in_super += 1
        end

        true
      end

      def end_visit(node : Call)
        if node.name == "super"
          @in_super -= 1
        end
      end

      def visit(node : ASTNode)
        true
      end
    end

    def gather_instance_vars_read(node)
      collector = InstanceVarsCollector.new(typed_def, scope, @vars)
      node.accept collector
      {collector.ivars, collector.found_self}
    end

    def expand_macro(node)
      obj = node.obj
      case obj
      when Path
        macro_scope = resolve_ident(obj)
        return false unless macro_scope.is_a?(Type)

        the_macro = macro_scope.metaclass.lookup_macro(node.name, node.args.size, node.named_args)
      when Nil
        return false if node.name == "super" || node.name == "previous_def"
        the_macro = node.lookup_macro
      else
        return false
      end

      return false unless the_macro

      @exp_nest -= 1

      generated_nodes = expand_macro(the_macro, node) do
        @mod.expand_macro (macro_scope || @scope || current_type), the_macro, node
      end

      @exp_nest += 1

      node.expanded = generated_nodes
      node.bind_to generated_nodes

      true
    end

    class PropagateDocVisitor < Visitor
      def initialize(@doc)
      end

      def visit(node : Expressions)
        true
      end

      def visit(node : ClassDef | ModuleDef | EnumDef | Def | FunDef | Alias | Assign)
        node.doc ||= @doc
        false
      end

      def visit(node : ASTNode)
        true
      end
    end

    def visit(node : MacroExpression)
      expand_inline_macro node
    end

    def visit(node : MacroIf)
      expand_inline_macro node
    end

    def visit(node : MacroFor)
      expand_inline_macro node
    end

    def expand_inline_macro(node)
      the_macro = Macro.new("macro_#{node.object_id}", [] of Arg, node).at(node.location)

      generated_nodes = expand_macro(the_macro, node) do
        @mod.expand_macro (@scope || current_type), node
      end

      node.expanded = generated_nodes
      node.bind_to generated_nodes

      false
    end

    def expand_macro(the_macro, node)
      begin
        expanded_macro = yield
      rescue ex : Crystal::Exception
        node.raise "expanding macro", ex
      end

      generated_nodes = @mod.parse_macro_source(expanded_macro, the_macro, node, Set.new(@vars.keys),
                                                inside_def: !!@typed_def,
                                                inside_type: !current_type.is_a?(Program),
                                                inside_exp: @exp_nest > 0,
                                                )

      if node_doc = node.doc
        generated_nodes.accept PropagateDocVisitor.new(node_doc)
      end

      old_var_names = @vars.keys

      generated_nodes.accept self

      # Make sure to delete variables declared by the macro, so that they
      # are not visible afterwards. However, keep the ones that start with
      # double underscore because those are generated by the compiler in case
      # like `x && y`. Also preserve special vars.
      if old_var_names.size != @vars.size
        @vars.delete_if do |name, var|
          !name.starts_with?('$') && !name.starts_with?("__") && !old_var_names.includes?(name)
        end
      end

      generated_nodes
    end

    def visit(node : Return)
      node.raise "can't return from top level" unless @typed_def

      node.exp.try &.accept self

      node.target = @typed_def

      typed_def = @typed_def.not_nil!
      typed_def.bind_to(node.exp || mod.nil_var)
      @unreachable = true

      false
    end

    def visit(node : Generic)
      node.in_type_args = @in_type_args > 0
      node.scope = @scope

      node.name.accept self

      @in_type_args += 1
      node.type_vars.each &.accept self
      @in_type_args -= 1

      return false if node.type?

      instance_type = node.name.type.instance_type
      unless instance_type.is_a?(GenericClassType)
        node.raise "#{instance_type} is not a generic class, it's a #{instance_type.type_desc}"
      end

      if instance_type.variadic
        min_needed = instance_type.type_vars.size - 1
        if node.type_vars.size < min_needed
          node.raise "wrong number of type vars for #{instance_type} (#{node.type_vars.size} for #{min_needed}..)"
        end
      else
        if instance_type.type_vars.size != node.type_vars.size
          node.raise "wrong number of type vars for #{instance_type} (#{node.type_vars.size} for #{instance_type.type_vars.size})"
        end
      end

      node.instance_type = instance_type
      node.type_vars.each &.add_observer(node)
      node.update

      false
    end

    def end_visit(node : Splat)
      node.bind_to node.exp
    end

    def visit(node : Underscore)
      if @in_type_args == 0
        node.raise "can't read from _"
      else
        node.raise "can't use underscore as generic type argument"
      end
    end

    def visit(node : IsA)
      node.obj.accept self

      @in_type_args += 1
      @in_is_a = true
      node.const.accept self
      @in_is_a = false
      @in_type_args -= 1

      node.type = mod.bool
      const = node.const

      # When doing x.is_a?(A) and A turns out to be a constant (not a type),
      # replace it with a === comparison. Most usually this happens in a case expression.
      if const.is_a?(Path) && const.target_const
        comp = Call.new(const, "===", node.obj).at(node.location)
        comp.accept self
        node.syntax_replacement = comp
        node.bind_to comp
        return
      end

      if needs_type_filters? && (var = get_expression_var(node.obj))
        @type_filters = TypeFilters.new var, SimpleTypeFilter.new(node.const.type)
      end

      false
    end

    def end_visit(node : RespondsTo)
      node.type = mod.bool
      if needs_type_filters? && (var = get_expression_var(node.obj))
        @type_filters = TypeFilters.new var, RespondsToTypeFilter.new(node.name)
      end
    end

    # Get the variable of an expression.
    # If it's a variable, it's that variable.
    # If it's an assignment to a variable, it's that variable.
    def get_expression_var(exp)
      case exp
      when Var
        return exp
      when Assign
        target = exp.target
        return target if target.is_a?(Var)
      end
      nil
    end

    def visit(node : Cast)
      node.obj.accept self

      @in_type_args += 1
      node.to.accept self
      @in_type_args -= 1

      obj_type = node.obj.type?
      if obj_type.is_a?(PointerInstanceType)
        to_type = node.to.type.instance_type
        if to_type.is_a?(GenericType)
          node.raise "can't cast #{obj_type} to #{to_type}"
        end
      end

      node.obj.add_observer node
      node.update

      false
    end

    def visit(node : ClassDef)
      check_outside_block_or_exp node, "declare class"

      node_superclass = node.superclass

      if node_superclass
        superclass = lookup_path_type(node_superclass)
      else
        superclass = node.struct ? mod.struct : mod.reference
      end

      if node_superclass.is_a?(Generic)
        unless superclass.is_a?(GenericClassType)
          node_superclass.raise "#{superclass} is not a generic class, it's a #{superclass.type_desc}"
        end

        if node_superclass.type_vars.size != superclass.type_vars.size
          node_superclass.raise "wrong number of type vars for #{superclass} (#{node_superclass.type_vars.size} for #{superclass.type_vars.size})"
        end
      end

      scope, name = process_type_name(node.name)

      type = scope.types[name]?

      if !type && superclass
        if (!!node.struct) != (!!superclass.struct?)
          node.raise "can't make #{node.struct ? "struct" : "class"} '#{node.name}' inherit #{superclass.type_desc} '#{superclass.to_s}'"
        end
      end

      created_new_type = false

      if type
        type = type.remove_alias

        unless type.is_a?(ClassType)
          node.raise "#{name} is not a #{node.struct ? "struct" : "class"}, it's a #{type.type_desc}"
        end

        if (!!node.struct) != (!!type.struct?)
          node.raise "#{name} is not a #{node.struct ? "struct" : "class"}, it's a #{type.type_desc}"
        end

        if node.superclass && type.superclass != superclass
          node.raise "superclass mismatch for class #{type} (#{superclass} for #{type.superclass})"
        end

        if type_vars = node.type_vars
          if type.is_a?(GenericType)
            type_type_vars = type.type_vars
            if type_vars != type_type_vars
              if type_type_vars.size == 1
                node.raise "type var must be #{type_type_vars.join ", "}, not #{type_vars.join ", "}"
              else
                node.raise "type vars must be #{type_type_vars.join ", "}, not #{type_vars.join ", "}"
              end
            end
          else
            node.raise "#{name} is not a generic #{type.type_desc}"
          end
        end
      else
        case superclass
        when NonGenericClassType
          # OK
        when GenericClassType
          if node_superclass.is_a?(Generic)
            mapping = Hash.zip(superclass.type_vars, node_superclass.type_vars)
            superclass = InheritedGenericClass.new(@mod, superclass, mapping)
          else
            node_superclass.not_nil!.raise "wrong number of type vars for #{superclass} (0 for #{superclass.type_vars.size})"
          end
        else
          node_superclass.not_nil!.raise "#{superclass} is not a class, it's a #{superclass.type_desc}"
        end

        created_new_type = true
        if type_vars = node.type_vars
          type = GenericClassType.new @mod, scope, name, superclass, type_vars, false
        else
          type = NonGenericClassType.new @mod, scope, name, superclass, false
        end
        type.abstract = node.abstract
        type.struct = node.struct

        if superclass.is_a?(InheritedGenericClass)
          superclass.extending_class = type
        end

        scope.types[name] = type
      end

      attach_doc type, node

      pushing_type(type) do
        if created_new_type
          run_hooks(superclass.metaclass, type, :inherited, node)
        end

        node.body.accept self
      end

      if created_new_type
        raise "Bug" unless type.is_a?(InheritableClass)
        type.force_add_subclass
      end

      node.type = @mod.nil

      false
    end

    def attach_doc(type, node)
      return unless @mod.wants_doc?

      type.doc ||= node.doc
      if node_location = node.location
        type.locations << node_location
      end
    end

    def run_hooks(type_with_hooks, current_type, kind, node)
      hooks = type_with_hooks.hooks
      if hooks
        hooks.each do |hook|
          next if hook.kind != kind

          expanded = expand_macro(hook.macro, node) do
            @mod.expand_macro current_type.instance_type, hook.macro.body
          end
          expanded.accept self
          node.add_runtime_initializer(expanded)
        end
      end

      if kind == :inherited && (superclass = type_with_hooks.instance_type.superclass)
        run_hooks(superclass.metaclass, current_type, kind, node)
      end
    end

    def visit(node : ModuleDef)
      check_outside_block_or_exp node, "declare module"

      scope, name = process_type_name(node.name)

      type = scope.types[name]?
      if type
        type = type.remove_alias

        unless type.module?
          node.raise "#{type} is not a module, it's a #{type.type_desc}"
        end
      else
        if type_vars = node.type_vars
          type = GenericModuleType.new @mod, scope, name, type_vars
        else
          type = NonGenericModuleType.new @mod, scope, name
        end
        scope.types[name] = type
      end

      attach_doc type, node

      pushing_type(type) do
        node.body.accept self
      end

      node.type = @mod.nil

      false
    end

    def visit(node : Alias)
      return false if @lib_def_pass == 2

      check_outside_block_or_exp node, "declare alias"

      existing_type = current_type.types[node.name]?
      if existing_type
        if existing_type.is_a?(AliasType)
          node.raise "alias #{node.name} is already defined"
        else
          node.raise "can't alias #{node.name} because it's already defined as a #{existing_type.type_desc}"
        end
      end

      alias_type = AliasType.new(@mod, current_type, node.name)

      attach_doc alias_type, node

      current_type.types[node.name] = alias_type
      node.value.accept self
      alias_type.aliased_type = node.value.type.instance_type

      node.type = @mod.nil

      false
    end

    def visit(node : Include)
      check_outside_block_or_exp node, "include"

      include_in current_type, node, :included

      node.type = @mod.nil

      false
    end

    def visit(node : Extend)
      check_outside_block_or_exp node, "extend"

      include_in current_type.metaclass, node, :extended

      node.type = @mod.nil

      false
    end

    def visit(node : LibDef)
      check_outside_block_or_exp node, "declare lib"

      link_attributes = process_link_attributes

      type = current_type.types[node.name]?
      if type
        node.raise "#{node.name} is not a lib" unless type.is_a?(LibType)
      else
        type = LibType.new @mod, current_type, node.name
        current_type.types[node.name] = type
      end

      type.add_link_attributes(link_attributes)

      pushing_type(type) do
        @lib_def_pass = 1
        node.body.accept self
        @lib_def_pass = 2
        node.body.accept self
        @lib_def_pass = 0
      end

      node.type = @mod.nil

      false
    end

    def process_link_attributes
      attributes = @attributes
      return unless attributes

      link_attributes = attributes.map do |attr|
        link_attribute_from_node(attr)
      end
      @attributes = nil
      link_attributes
    end

    def link_attribute_from_node(attr)
      name = attr.name
      args = attr.args
      named_args = attr.named_args

      if name != "Link"
        attr.raise "illegal attribute for lib, valid attributes are: Link"
      end

      if args.empty? && !named_args
        attr.raise "missing link arguments: must at least specify a library name"
      end

      lib_name = nil
      lib_ldflags = nil
      lib_static = false
      lib_framework = nil
      count = 0

      args.each do |arg|
        case count
        when 0
          unless arg.is_a?(StringLiteral)
            arg.raise "'lib' link argument must be a String"
          end
          lib_name = arg.value
        when 1
          unless arg.is_a?(StringLiteral)
            arg.raise "'ldflags' link argument must be a String"
          end
          lib_ldflags = arg.value
        when 2
          unless arg.is_a?(BoolLiteral)
            arg.raise "'static' link argument must be a Bool"
          end
          lib_static = arg.value
        when 3
          unless arg.is_a?(StringLiteral)
            arg.raise "'framework' link argument must be a String"
          end
          lib_framework = arg.value
        else
          attr.raise "wrong number of link arguments (#{args.size} for 1..4)"
        end

        count += 1
      end

      named_args.try &.each do |named_arg|
        value = named_arg.value

        case named_arg.name
        when "lib"
          if count > 0
            named_arg.raise "'lib' link argument already specified"
          end
          unless value.is_a?(StringLiteral)
            named_arg.raise "'lib' link argument must be a String"
          end
          lib_name = value.value
        when "ldflags"
          if count > 1
            named_arg.raise "'ldflags' link argument already specified"
          end
          unless value.is_a?(StringLiteral)
            named_arg.raise "'ldflags' link argument must be a String"
          end
          lib_ldflags = value.value
        when "static"
          if count > 2
            named_arg.raise "'static' link argument already specified"
          end
          unless value.is_a?(BoolLiteral)
            named_arg.raise "'static' link argument must be a Bool"
          end
          lib_static = value.value
        when "framework"
          if count > 3
            named_arg.raise "'framework' link argument already specified"
          end
          unless value.is_a?(StringLiteral)
            named_arg.raise "'framework' link argument must be a String"
          end
          lib_framework = value.value
        else
          named_arg.raise "unkonwn link argument: '#{named_arg.name}' (valid arguments are 'lib', 'ldflags', 'static' and 'framework')"
        end
      end

      LinkAttribute.new(lib_name, lib_ldflags, lib_static, lib_framework)
    end

    def visit(node : FunDef)
      return false if @lib_def_pass == 1

      check_outside_block_or_exp node, "declare fun"

      if node.body && !current_type.is_a?(Program)
        node.raise "can only declare fun at lib or global scope"
      end

      call_convention = check_call_convention_attributes node
      check_valid_attributes node, ValidFunDefAttributes, "fun"
      node.doc ||= attributes_doc()

      args = node.args.map do |arg|
        restriction = arg.restriction.not_nil!
        restriction.accept self

        arg_type = check_arg_primitive_like(restriction.not_nil!)

        Arg.new(arg.name, type: arg_type).at(arg.location)
      end

      node_return_type = node.return_type
      if node_return_type
        node_return_type.accept self
        return_type = check_primitive_like(node_return_type)
      else
        return_type = @mod.void
      end

      external = External.for_fun(node.name, node.real_name, args, return_type, node.varargs, node.body, node)
      external.doc = node.doc
      check_ditto external

      external.call_convention = call_convention

      if node_body = node.body
        vars = MetaVars.new
        args.each do |arg|
          var = MetaVar.new(arg.name, arg.type)
          var.bind_to var
          vars[arg.name] = var
        end
        external.set_type(nil)

        visitor = TypeVisitor.new(@mod, vars, external)
        visitor.untyped_def = external
        visitor.scope = @mod
        visitor.block_nest = @block_nest

        begin
          node_body.accept visitor
        rescue ex : Crystal::Exception
          node.raise ex.message, ex
        end

        inferred_return_type = @mod.type_merge([node_body.type?, external.type?])

        if return_type && return_type != @mod.void && inferred_return_type != return_type
          node.raise "expected fun to return #{return_type} but it returned #{inferred_return_type}"
        end

        external.set_type(return_type)
      end

      external.raises = true if node.has_attribute?("Raises")

      begin
        old_external = current_type.add_def external
      rescue ex : Crystal::Exception
        node.raise ex.message
      end

      if old_external.is_a?(External)
        old_external.dead = true
      end

      if node.body
        key = DefInstanceKey.new external.object_id, external.args.map(&.type), nil, nil
        current_type.add_def_instance key, external
      end

      node.type = @mod.nil

      false
    end

    def end_visit(node : TypeDef)
      return if @lib_def_pass == 2

      type = current_type.types[node.name]?
      if type
        node.raise "#{node.name} is already defined"
      else
        typed_def_type = check_primitive_like node.type_spec
        current_type.types[node.name] = TypeDefType.new @mod, current_type, node.name, typed_def_type
      end
    end

    def visit(node : StructDef)
      if @lib_def_pass == 1
        check_valid_attributes node, ValidStructDefAttributes, "struct"
      end

      type = process_struct_or_union_def(node, CStructType) do |t|
        unless t.is_a?(CStructType)
          node.raise "#{node.name} is already defined as #{t.type_desc}"
        end
      end

      if @lib_def_pass == 1
        if node.has_attribute?("Packed")
          (type as CStructType).packed = true
        end
      end

      false
    end

    def visit(node : UnionDef)
      process_struct_or_union_def(node, CUnionType) do |t|
        unless t.is_a?(CUnionType)
          node.raise "#{node.name} is already defined as #{t.type_desc}"
        end
      end

      false
    end

    def visit(node : EnumDef)
      return false if @lib_def_pass == 2

      check_outside_block_or_exp node, "declare enum"

      check_valid_attributes node, ValidEnumDefAttributes, "enum"

      scope, name = process_type_name(node.name)

      enum_type = scope.types[name]?
      if enum_type
        unless enum_type.is_a?(EnumType)
          node.raise "#{name} is not a enum, it's a #{enum_type.type_desc}"
        end
      end

      if base_type = node.base_type
        base_type.accept self
        enum_base_type = base_type.type.instance_type
        unless enum_base_type.is_a?(IntegerType)
          base_type.raise "enum base type must be an integer type"
        end
      else
        enum_base_type = @mod.int32
      end

      is_flags = node.has_attribute?("Flags")
      all_value = 0_u64
      existed = !!enum_type
      enum_type ||= EnumType.new(@mod, scope, name, enum_base_type, is_flags)

      attach_doc enum_type, node

      enum_type.doc ||= attributes_doc()
      enum_type.add_attributes(@attributes)
      @attributes = nil

      pushing_type(enum_type) do
        counter = is_flags ? 1 : 0
        node.members.each do |member|
          case member
          when Arg
            if existed
              node.raise "can't reopen enum and add more constants to it"
            end

            if default_value = member.default_value
              counter = interpret_enum_value(default_value, enum_base_type)
            end
            all_value |= counter
            const_value = NumberLiteral.new(counter, enum_base_type.kind)
            member.default_value = const_value
            if enum_type.types.has_key?(member.name)
              member.raise "enum '#{enum_type}' already contains a member named '#{member.name}'"
            end
            const_member = enum_type.add_constant member
            const_member.doc = member.doc
            check_ditto const_member

            if member_location = member.location
              const_member.locations << member_location
            end

            const_value.type = enum_type
            counter = is_flags ? counter * 2 : counter + 1
          when Def, Assign, VisibilityModifier
            member.accept self
          end
        end
      end

      unless existed
        if is_flags
          unless enum_type.types["None"]?
            none = NumberLiteral.new(0, enum_base_type.kind)
            none.type = enum_type
            enum_type.add_constant Arg.new("None", default_value: none)
          end

          unless enum_type.types["All"]?
            all = NumberLiteral.new(all_value, enum_base_type.kind)
            all.type = enum_type
            enum_type.add_constant Arg.new("All", default_value: all)
          end
        end

        node.enum_type = scope.types[name] = enum_type
      end

      node.type = mod.nil

      false
    end

    def interpret_enum_value(node : NumberLiteral, target_type)
      case node.kind
      when :i8, :i16, :i32, :i64, :u8, :u16, :u32, :u64, :i64
        case target_type.kind
        when :i8 then node.value.to_i8? || node.raise "invalid Int8: #{node.value}"
        when :u8 then node.value.to_u8? || node.raise "invalid UInt8: #{node.value}"
        when :i16 then node.value.to_i16? || node.raise "invalid Int16: #{node.value}"
        when :u16 then node.value.to_u16? || node.raise "invalid UInt16: #{node.value}"
        when :i32 then node.value.to_i32? || node.raise "invalid Int32: #{node.value}"
        when :u32 then node.value.to_u32? || node.raise "invalid UInt32: #{node.value}"
        when :i64 then node.value.to_i64? || node.raise "invalid Int64: #{node.value}"
        when :u64 then node.value.to_u64? || node.raise "invalid UInt64: #{node.value}"
        else
          node.raise "enum type must be an integer, not #{target_type.kind}"
        end
      else
        node.raise "constant value must be an integer, not #{node.kind}"
      end
    end

    def interpret_enum_value(node : Call, target_type)
      obj = node.obj
      unless obj
        node.raise "invalid constant value"
      end
      if node.args.size != 1
        node.raise "invalid constant value"
      end

      left = interpret_enum_value(obj, target_type)
      right = interpret_enum_value(node.args.first, target_type)

      case node.name
      when "+"  then left + right
      when "-"  then left - right
      when "*"  then left * right
      when "/"  then left / right
      when "&"  then left & right
      when "|"  then left | right
      when "<<" then left << right
      when ">>" then left >> right
      when "%"  then left % right
      else
        node.raise "invalid constant value"
      end
    end

    def interpret_enum_value(node : Path, target_type)
      type = resolve_ident(node)
      case type
      when Const
        interpret_enum_value(type.value, target_type)
      else
        node.raise "invalid constant value"
      end
    end

    def interpret_enum_value(node : ASTNode, target_type)
      node.raise "invalid constant value"
    end

    def visit(node : ExternalVar)
      check_valid_attributes node, ValidExternalVarAttributes, "external var"

      node.type_spec.accept self

      var_type = check_primitive_like node.type_spec

      type = current_type as LibType
      type.add_var node.name, var_type, (node.real_name || node.name), node.attributes

      false
    end

    def visit(node : Path)
      type = resolve_ident(node)
      case type
      when Const
        if !type.value.type? && !type.visited?
          type.visited = true

          meta_vars = MetaVars.new
          const_def = Def.new("const", [] of Arg)
          type_visitor = TypeVisitor.new(@mod, meta_vars, const_def)
          type_visitor.types = type.scope_types
          type_visitor.scope = type.scope

          type.value.accept type_visitor
          type.vars = const_def.vars
          type.visitor = self
        end
        node.target_const = type
        node.bind_to type.value
        type.used = true
      when Type
        if type.is_a?(AliasType) && @in_type_args == 0 && !type.aliased_type?
          node.raise "infinite recursive definition of alias #{type}"
        end

        node.type = check_type_in_type_args(type.remove_alias_if_simple)
      when ASTNode
        node.syntax_replacement = type
        node.bind_to type
      end
    end

    def end_visit(node : Union)
      old_in_is_a, @in_is_a = @in_is_a, false

      types = node.types.map do |subtype|
        instance_type = subtype.type.instance_type
        unless instance_type.allowed_in_generics?
          subtype.raise "can't use #{instance_type} in unions yet, use a more specific type"
        end
        instance_type
      end

      @in_is_a = old_in_is_a

      if @in_is_a
        node.type = @mod.type_merge_union_of(types)
      else
        node.type = @mod.type_merge(types)
      end
    end

    def end_visit(node : Virtual)
      node.type = check_type_in_type_args node.name.type.instance_type.virtual_type
    end

    def end_visit(node : Metaclass)
      node.type = node.name.type.virtual_type!.metaclass
    end

    def check_type_in_type_args(type)
      if @in_type_args > 0
        type
      else
        type.metaclass
      end
    end

    def visit(node : If)
      request_type_filters do
        node.cond.accept self
      end

      cond_type_filters = @type_filters
      cond_vars = @vars

      @type_filters = nil
      @vars = cond_vars.dup
      @unreachable = false

      filter_vars cond_type_filters

      node.then.accept self

      then_vars = @vars
      then_type_filters = @type_filters
      @type_filters = nil
      then_unreachable = @unreachable

      @vars = cond_vars.dup
      @unreachable = false

      # The only cases where we can deduce something for the 'else'
      # block is when the condition is a Var (in the else it must be
      # nil), IsA (in the else it's not that type) or RespondsTo
      # (in the else it doesn't respond to that message).
      case node.cond
      when Var, IsA, RespondsTo
        filter_vars cond_type_filters, &.not
      end

      node.else.accept self

      else_vars = @vars
      else_type_filters = @type_filters
      @type_filters = nil
      else_unreachable = @unreachable

      merge_if_vars node, cond_vars, then_vars, else_vars, then_unreachable, else_unreachable

      if needs_type_filters?
        case node.binary
        when :and
          @type_filters = TypeFilters.and(cond_type_filters, then_type_filters, else_type_filters)
        # TODO: or type filters
        # when :or
        #   node.type_filters = or_type_filters(node.then.type_filters, node.else.type_filters)
        end
      end

      @unreachable = then_unreachable && else_unreachable

      node.bind_to [node.then, node.else]

      false
    end

    # Here we merge the variables from both branches of an if.
    # We basically:
    #   - Create a variable whose type is the merged types of the last
    #     type of each branch.
    #   - Make the variable nilable if the variable wasn't declared
    #     before the 'if' and it doesn't appear in one of the branches.
    #   - Don't use the type of a branch that is unreachable (ends with return,
    #     break or with a call that is NoReturn)
    def merge_if_vars(node, cond_vars, then_vars, else_vars, then_unreachable, else_unreachable)
      all_vars_names = Set(String).new
      then_vars.each_key do |name|
        all_vars_names << name
      end
      else_vars.each_key do |name|
        all_vars_names << name
      end

      all_vars_names.each do |name|
        cond_var = cond_vars[name]?
        then_var = then_vars[name]?
        else_var = else_vars[name]?

        # Check wether the var didn't change at all
        next if then_var.same?(else_var)

        if_var = MetaVar.new(name)
        if_var.nil_if_read = !!(then_var.try(&.nil_if_read) || else_var.try(&.nil_if_read))

        if then_var && else_var
          if then_unreachable
            if_var.bind_to conditional_no_return(node.then, then_var)
          else
            if_var.bind_to then_var
          end

          if else_unreachable
            if_var.bind_to conditional_no_return(node.else, else_var)
          else
            if_var.bind_to else_var
          end
        elsif then_var
          if then_unreachable
            if_var.bind_to conditional_no_return(node.then, then_var)
          else
            if_var.bind_to then_var
          end

          if cond_var
            if_var.bind_to cond_var
          elsif !else_unreachable
            if_var.bind_to mod.nil_var
            if_var.nil_if_read = true
          else
            if_var.bind_to conditional_no_return(node.else, @mod.nil_var)
          end
        elsif else_var
          if else_unreachable
            if_var.bind_to conditional_no_return(node.else, else_var)
          else
            if_var.bind_to else_var
          end

          if cond_var
            if_var.bind_to cond_var
          elsif !then_unreachable
            if_var.bind_to mod.nil_var
            if_var.nil_if_read = true
          else
            if_var.bind_to conditional_no_return(node.then, @mod.nil_var)
          end
        end

        @vars[name] = if_var
      end
    end

    def conditional_no_return(node, var)
       node.filtered_by NoReturnFilter.new(var)
    end

    def visit(node : While)
      old_while_vars = @while_vars
      before_cond_vars = @vars.dup

      request_type_filters do
        node.cond.accept self
      end

      cond_type_filters = @type_filters

      after_cond_vars = @vars.dup
      @while_vars = after_cond_vars

      filter_vars cond_type_filters

      @type_filters = nil
      @block, old_block = nil, @block

      @while_stack.push node
      node.body.accept self

      endless_while = node.cond.true_literal?
      merge_while_vars node.cond, endless_while, before_cond_vars, after_cond_vars, @vars, node.break_vars

      @while_stack.pop
      @block = old_block
      @while_vars = old_while_vars

      unless node.has_breaks
        if endless_while
          node.type = mod.no_return
          return
        end
      end

      node.type = @mod.nil

      false
    end

    # Here we assign the types of variables after a while.
    def merge_while_vars(cond, endless, before_cond_vars, after_cond_vars, while_vars, all_break_vars)
      after_while_vars = MetaVars.new

      cond_var = get_while_cond_assign_target(cond)

      while_vars.each do |name, while_var|
        before_cond_var = before_cond_vars[name]?
        after_cond_var = after_cond_vars[name]?

        # If a variable was assigned in the condition, it has that type.
        if cond_var && (cond_var.name == name) && after_cond_var && !after_cond_var.same?(before_cond_var)
          after_while_var = MetaVar.new(name)
          after_while_var.bind_to(after_cond_var)
          after_while_var.nil_if_read = after_cond_var.nil_if_read
          after_while_vars[name] = after_while_var

        # If there was a previous variable, we use that type merged
        # with the last type inside the while.
        elsif before_cond_var
          before_cond_var.bind_to(while_var)
          after_while_var = MetaVar.new(name)

          # If the loop is endless
          if endless
            after_while_var.bind_to(while_var)
            after_while_var.nil_if_read = while_var.nil_if_read
          else
            after_while_var.bind_to(before_cond_var)
            after_while_var.bind_to(while_var)
            after_while_var.nil_if_read = before_cond_var.nil_if_read || while_var.nil_if_read
          end
          after_while_vars[name] = after_while_var

        # Otherwise, it's a new variable inside the while: used
        # outside it must be nilable, unless the loop is endless.
        else
          after_while_var = MetaVar.new(name)
          after_while_var.bind_to(while_var)
          nilable = false
          if endless
            # In an endless loop if there's a break before a variable is declared,
            # that variable becomes nilable.
            unless all_break_vars.try &.all? &.has_key?(name)
              nilable = true
            end
          else
            nilable = true
          end
          if nilable
            after_while_var.bind_to(@mod.nil_var)
            after_while_var.nil_if_read = true
          end
          after_while_vars[name] = after_while_var
        end
      end

      @vars = after_while_vars

      # We also need to merge types from breaks inside while.
      if all_break_vars
        all_break_vars.each do |break_vars|
          break_vars.each do |name, var|
            @vars[name].bind_to(var)
          end
        end
      end
    end

    def get_while_cond_assign_target(node)
      case node
      when Assign
        target = node.target
        if target.is_a?(Var)
          return target
        end
      when And
        return get_while_cond_assign_target(node.left)
      when If
        if node.binary == :and
          return get_while_cond_assign_target(node.cond)
        end
      when Call
        return get_while_cond_assign_target(node.obj)
      end

      nil
    end

    # If we have:
    #
    #   if a
    #     ...
    #   end
    #
    # then inside the if 'a' must not be nil.
    #
    # This is what we do here: we create a meta-variable for
    # it and filter it accordingly. This also applied to
    # .is_a? and .responds_to?.
    #
    # This also applies to 'while' conditions and also
    # to the else part of an if, but with filters inverted.
    def filter_vars(filters)
      filter_vars(filters) { |filter| filter }
    end

    def filter_vars(filters)
      filters.try &.each do |name, filter|
        existing_var = @vars[name]
        filtered_var = MetaVar.new(name)
        filtered_var.bind_to(existing_var.filtered_by(yield filter))
        @vars[name] = filtered_var
      end
    end

    def end_visit(node : Break)
      if target_block = block
        node.target = target_block.call.not_nil!

        target_block.break.bind_to(node.exp || mod.nil_var)

        bind_vars @vars, target_block.after_vars
      elsif target_while = @while_stack.last?
        node.target = target_while
        target_while.has_breaks = true

        break_vars = (target_while.break_vars ||= [] of MetaVars)
        break_vars.push @vars.dup
      else
        node.raise "Invalid break"
      end

      @unreachable = true
    end

    def end_visit(node : Next)
      if block = @block
        node.target = block

        block.bind_to(node.exp || mod.nil_var)

        bind_vars @vars, block.vars
        bind_vars @vars, block.after_vars
      elsif target_while = @while_stack.last?
        node.target = target_while

        bind_vars @vars, @while_vars
      else
        node.raise "Invalid next"
      end

      @unreachable = true
    end

    def visit(node : Primitive)
      case node.name
      when :binary
        visit_binary node
      when :cast
        visit_cast node
      when :allocate
        visit_allocate node
      when :pointer_malloc
        visit_pointer_malloc node
      when :pointer_set
        visit_pointer_set node
      when :pointer_get
        visit_pointer_get node
      when :pointer_address
        node.type = @mod.uint64
      when :pointer_new
        visit_pointer_new node
      when :pointer_realloc
        node.type = scope
      when :pointer_add
        node.type = scope
      when :argc
        node.type = @mod.int32
      when :argv
        node.type = @mod.pointer_of(@mod.pointer_of(@mod.uint8))
      when :struct_new
        node.type = scope.instance_type
      when :struct_set
        node.bind_to @vars["value"]
      when :struct_get
        visit_struct_get node
      when :union_new
        node.type = scope.instance_type
      when :union_set
        node.bind_to @vars["value"]
      when :union_get
        visit_union_get node
      when :external_var_set
        # Nothing to do
      when :external_var_get
        # Nothing to do
      when :object_id
        node.type = mod.uint64
      when :object_crystal_type_id
        node.type = mod.int32
      when :symbol_hash
        node.type = mod.int32
      when :symbol_to_s
        node.type = mod.string
      when :class
        node.type = scope.metaclass
      when :fun_call
        # Nothing to do
      when :pointer_diff
        node.type = mod.int64
      when :class_name
        node.type = mod.string
      when :enum_value
        # Nothing to do
      when :enum_new
        # Nothing to do
      else
        node.raise "Bug: unhandled primitive in type inference: #{node.name}"
      end
    end

    def visit_binary(node)
      case typed_def.name
      when "+", "-", "*", "/", "unsafe_div"
        t1 = scope.remove_typedef
        t2 = typed_def.args[0].type
        node.type = t1.integer? && t2.float? ? t2 : scope
      when "==", "<", "<=", ">", ">=", "!="
        node.type = @mod.bool
      when "%", "unsafe_shl", "unsafe_shr", "|", "&", "^", "unsafe_mod"
        node.type = scope
      else
        raise "Bug: unknown binary operator #{typed_def.name}"
      end
    end

    def visit_cast(node)
      node.type =
        case typed_def.name
        when "to_i", "to_i32", "ord" then mod.int32
        when "to_i8" then mod.int8
        when "to_i16" then mod.int16
        when "to_i32" then mod.int32
        when "to_i64" then mod.int64
        when "to_u", "to_u32" then mod.uint32
        when "to_u8" then mod.uint8
        when "to_u16" then mod.uint16
        when "to_u32" then mod.uint32
        when "to_u64" then mod.uint64
        when "to_f", "to_f64" then mod.float64
        when "to_f32" then mod.float32
        when "chr" then mod.char
        else
          raise "Bug: unkown cast operator #{typed_def.name}"
        end
    end

    def visit_allocate(node)
      instance_type = scope.instance_type

      if instance_type.is_a?(GenericClassType)
        node.raise "can't create instance of generic class #{instance_type} without specifying its type vars"
      end

      if !instance_type.virtual? && instance_type.abstract
        node.raise "can't instantiate abstract #{instance_type.type_desc} #{instance_type}"
      end

      instance_type.allocated = true
      node.type = instance_type
    end

    def visit_pointer_malloc(node)
      if scope.instance_type.is_a?(GenericClassType)
        node.raise "can't malloc pointer without type, use Pointer(Type).malloc(size)"
      end

      node.type = scope.instance_type
    end

    def visit_pointer_set(node)
      scope = scope().remove_typedef as PointerInstanceType

      value = @vars["value"]

      scope.var.bind_to value
      node.bind_to value
    end

    def visit_pointer_get(node)
      scope = scope().remove_typedef as PointerInstanceType

      node.bind_to scope.var
    end

    def visit_pointer_new(node)
      if scope.instance_type.is_a?(GenericClassType)
        node.raise "can't create pointer without type, use Pointer(Type).new(address)"
      end

      node.type = scope.instance_type
    end

    def visit_struct_get(node)
      scope = @scope as CStructType
      node.bind_to scope.vars[untyped_def.name]
    end

    def visit_union_get(node)
      scope = @scope as CUnionType
      node.bind_to scope.vars[untyped_def.name]
    end

    def visit(node : Self)
      the_self = (@scope || current_type)
      if the_self.is_a?(Program)
        node.raise "there's no self in this scope"
      end

      node.type = the_self.instance_type
    end

    def visit(node : PointerOf)
      var = case node_exp = node.exp
            when Var
              meta_var = @meta_vars[node_exp.name]
              meta_var.assigned_to = true
              meta_var
            when InstanceVar
              lookup_instance_var node_exp
            when ClassVar
              visit_class_var node_exp
            when Global
              visit_global node_exp
            when Path
              node_exp.accept self
              if const = node_exp.target_const
                const.value
              else
                node_exp.raise "can't take address of #{node_exp}"
              end
            when ReadInstanceVar
              visit_read_instance_var node_exp
            else
              node_exp.raise "can't take address of #{node_exp}"
            end
      node.bind_to var
    end

    def visit(node : TypeOf)
      # A typeof shouldn't change the type of variables:
      # so we keep the ones before it and restore them at the end
      old_vars = @vars.dup

      node.in_type_args = @in_type_args > 0

      old_in_type_args = @in_type_args
      @in_type_args = 0

      @typeof_nest += 1
      node.expressions.each &.accept self
      @typeof_nest -= 1

      @in_type_args = old_in_type_args

      node.bind_to node.expressions

      @vars = old_vars

      false
    end

    def end_visit(node : SizeOf)
      node.type = @mod.int32
    end

    def end_visit(node : InstanceSizeOf)
      node.type = @mod.int32
    end

    def visit(node : Rescue)
      if node_types = node.types
        types = node_types.map do |type|
          type.accept self
          instance_type = type.type.instance_type
          unless instance_type.is_subclass_of?(@mod.exception)
            type.raise "#{type} is not a subclass of Exception"
          end
          instance_type
        end
      end

      if node_name = node.name
        var = @vars[node_name] = new_meta_var(node_name)
        meta_var = (@meta_vars[node_name] ||= new_meta_var(node_name))
        meta_var.bind_to(var)

        if types
          unified_type = @mod.type_merge(types).not_nil!
          unified_type = unified_type.virtual_type unless unified_type.is_a?(VirtualType)
        else
          unified_type = @mod.exception.virtual_type
        end
        var.type = unified_type
        var.freeze_type = unified_type

        node.set_type(var.type)
      end

      node.body.accept self

      false
    end

    def visit(node : ExceptionHandler)
      old_exception_handler_vars = @exception_handler_vars

      # Save old vars to know if new variables are declared inside begin/rescue/else
      before_body_vars = @vars.dup

      # Any variable assigned in the body (begin) will have, inside rescue
      # blocks, all types that were assigned to them, because we can't know at which
      # point an exception is raised.
      exception_handler_vars = @exception_handler_vars = @vars.dup

      node.body.accept self

      # We need the variables after the begin block to use in the else,
      # but we don't dup them if we don't need them
      if node.else
        after_exception_handler_vars = @vars.dup
      end

      @exception_handler_vars = nil

      if node.rescues || node.else
        # Any variable introduced in the begin block is possibly nil
        # in the rescue blocks because we can't know if an exception
        # was raised before assigning any of the vars.
        exception_handler_vars.each do |name, var|
          unless before_body_vars[name]?
            var.nil_if_read = true
          end
        end

        # Now, using these vars, visit all rescue blocks and keep
        # the results in this variable.
        all_rescue_vars = [] of MetaVars

        node.rescues.try &.each do |a_rescue|
          @vars = exception_handler_vars.dup
          @unreachable = false
          a_rescue.accept self
          all_rescue_vars << @vars unless @unreachable
        end

        # In the else block the types are the same as in the begin block,
        # because we assume no exception was raised.
        node.else.try do |a_else|
          @vars = after_exception_handler_vars.not_nil!.dup
          @unreachable = false
          a_else.accept self
          all_rescue_vars << @vars unless @unreachable
        end

        # If all rescue/else blocks are unreachable, then afterwards
        # the flow continues as if there were no rescue/else blocks.
        if all_rescue_vars.empty?
          all_rescue_vars = nil
        else
          # Otherwise, merge all types that resulted from all rescue/else blocks
          merge_rescue_vars exception_handler_vars, all_rescue_vars

          # And then accept the ensure part
          node.ensure.try &.accept self
        end
      end

      # If there were no rescue/else blocks or all of them were unreachable
      unless all_rescue_vars
        if node_ensure = node.ensure
          after_handler_vars = @vars
          @vars = exception_handler_vars

          # Variables in the ensure block might be nil because we don't know
          # if an exception was thrown before any assignment.
          @vars.each do |name, var|
            unless before_body_vars[name]?
              var.nil_if_read = true
            end
          end

          node_ensure.accept self

          @vars = after_handler_vars
        end

        # However, those previous variables can't be nil afterwards:
        # if an exception was raised then we won't running the code
        # after the ensure clause, so variables don't matter. But if
        # an exception was not raised then all variables were declared
        # successfuly.
        @vars.each do |name, var|
          unless before_body_vars[name]?
            var.nil_if_read = false
          end
        end
      end

      if node_ensure = node.ensure
        node_ensure.add_observer(node)
      end

      if node_else = node.else
        node.bind_to node_else
      else
        node.bind_to node.body
      end

      if node_rescues = node.rescues
        node_rescues.each do |a_rescue|
          node.bind_to a_rescue.body
        end
      end

      old_exception_handler_vars = @exception_handler_vars

      false
    end

    def merge_rescue_vars(body_vars, all_rescue_vars)
      after_vars = MetaVars.new

      all_rescue_vars.each do |rescue_vars|
        rescue_vars.each do |name, var|
          after_var = (after_vars[name] ||= new_meta_var(name))
          if var.nil_if_read || !body_vars[name]?
            after_var.nil_if_read = true
          end
          after_var.bind_to(var)
        end
      end

      body_vars.each do |name, var|
        after_var = (after_vars[name] ||= new_meta_var(name))
        after_var.bind_to(var)
      end

      @vars = after_vars
    end

    def end_visit(node : TupleLiteral)
      node.elements.each &.add_observer(node)
      node.mod = @mod
      node.update
      false
    end

    def visit(node : TupleIndexer)
      scope = @scope
      if scope.is_a?(TupleInstanceType)
        node.type = scope.tuple_types[node.index] as Type
      elsif scope
        node.type = ((scope.instance_type as TupleInstanceType).tuple_types[node.index] as Type).metaclass
      end
      false
    end

    def visit(node : VisibilityModifier)
      node.exp.visibility = node.modifier
      node.exp.accept self
      node.type = @mod.nil

      # Can only apply visibility modifier to def, macro or a macro call
      case exp = node.exp
      when Def
        return false
      when Macro
        return false
      when Call
        if exp.expanded
          return false
        end
      end

      node.raise "can't apply visibility modifier"
    end

    def visit(node : Asm)
      if output = node.output
        ptrof = PointerOf.new(output.exp).at(output.exp)
        ptrof.accept self
        node.ptrof = ptrof
      end

      if inputs = node.inputs
        inputs.each &.exp.accept self
      end

      node.type = @mod.void
      false
    end

    def include_in(current_type, node, kind)
      node_name = node.name
      type = lookup_path_type(node_name)

      unless type.module?
        node_name.raise "#{type} is not a module, it's a #{type.type_desc}"
      end

      if node_name.is_a?(Generic)
        unless type.is_a?(GenericModuleType)
          node_name.raise "#{type} is not a generic module"
        end

        if type.type_vars.size != node_name.type_vars.size
          node_name.raise "wrong number of type vars for #{type} (#{node_name.type_vars.size} for #{type.type_vars.size})"
        end

        mapping = Hash.zip(type.type_vars, node_name.type_vars)
        module_to_include = IncludedGenericModule.new(@mod, type, current_type, mapping)
      else
        if type.is_a?(GenericModuleType)
          node_name.raise "#{type} is a generic module"
        else
          module_to_include = type
        end
      end

      begin
        current_type.include module_to_include
        run_hooks type.metaclass, current_type, kind, node
      rescue ex : TypeException
        node.raise "at '#{kind}' hook", ex
      end
    end

    class StructOrUnionVisitor < Visitor
      def initialize(@type_inference, @struct_or_union)
      end

      def visit(field : Arg)
        field.accept @type_inference
        restriction = field.restriction.not_nil!
        field_type = @type_inference.check_primitive_like restriction
        if field_type.remove_typedef.void?
          if @struct_or_union.is_a?(CStructType)
            restriction.raise "can't use Void as a struct field type"
          else
            restriction.raise "can't use Void as a union field type"
          end
        end

        if @struct_or_union.has_var?(field.name)
          field.raise "#{@struct_or_union.type_desc} #{@struct_or_union} already defines a field named '#{field.name}'"
        end
        @struct_or_union.add_var MetaInstanceVar.new(field.name, field_type)
      end

      def visit(node : Include)
        node.name.accept @type_inference
        type = node.name.type.instance_type
        unless type.is_a?(CStructType)
          node.name.raise "can only include C struct, not #{type.type_desc}"
        end

        type.vars.each_value do |var|
          if @struct_or_union.has_var?(var.name)
            node.raise "struct #{type} has a field named '#{var.name}', which #{@struct_or_union} already defines"
          end
          @struct_or_union.add_var(var)
        end

        false
      end

      def visit(node : ASTNode)
        true
      end
    end

    def process_struct_or_union_def(node, klass)
      type = current_type.types[node.name]?
      if type
        yield type
        type = type as CStructOrUnionType
        unless type.vars.empty?
          node.raise "#{node.name} is already defined"
        end
      else
        type = current_type.types[node.name] = klass.new @mod, current_type, node.name
      end

      if @lib_def_pass == 2
        pushing_type(type) do
          node.body.accept StructOrUnionVisitor.new(self, type)
        end
      end

      node.type = type

      type
    end

    def check_call_convention_attributes(node)
      attributes = @attributes
      return unless attributes

      call_convention = nil

      attributes.delete_if do |attr|
        next false unless attr.name == "CallConvention"

        if call_convention
          attr.raise "call convention already specified"
        end

        if attr.args.size != 1
          attr.raise "wrong number of arguments for attribute CallConvention (#{attr.args.size} for 1)"
        end

        call_convention_node = attr.args.first
        unless call_convention_node.is_a?(StringLiteral)
          call_convention_node.raise "argument to CallConvention must be a string"
        end

        value = call_convention_node.value
        call_convention = LLVM::CallConvention.parse?(value)
        unless call_convention
          call_convention_node.raise "invalid call convention. Valid values are #{LLVM::CallConvention.values.join ", "}"
        end

        true
      end

      call_convention
    end

    def check_valid_attributes(node, valid_attributes, desc)
      if attributes = @attributes
        attributes.each do |attr|
          unless valid_attributes.includes?(attr.name)
            attr.raise "illegal attribute for #{desc}, valid attributes are: #{valid_attributes.join ", "}"
          end

          if !attr.args.empty? || attr.named_args
            attr.raise "#{attr.name} attribute can't receive arguments"
          end
        end
        node.attributes = attributes
      end
    end

    def attributes_doc
      @attributes.try(&.first?).try &.doc
    end

    def check_ditto(node)
      stripped_doc = node.doc.try &.strip
      if stripped_doc == ":ditto:" || stripped_doc == "ditto"
        node.doc = @last_doc
      end

      @last_doc = node.doc
    end

    def process_type_name(node_name)
      if node_name.names.size == 1 && !node_name.global
        scope = current_type
        name = node_name.names.first
      else
        name = node_name.names.pop
        scope = lookup_path_type node_name, create_modules_if_missing: true
      end
      {scope, name}
    end

    def lookup_path_type(node : Self, create_modules_if_missing = false)
      current_type
    end

    def lookup_path_type(node : Path, create_modules_if_missing = false)
      target_type = resolve_ident(node, create_modules_if_missing)
      if target_type.is_a?(Type)
        target_type.remove_alias_if_simple
      else
        node.raise "#{node} must be a type here, not #{target_type}"
      end
    end

    def lookup_path_type(node : Generic, create_modules_if_missing = false)
      lookup_path_type node.name, create_modules_if_missing
    end

    def lookup_path_type(node, create_modules_if_missing = false)
      raise "lookup_path_type not implemented for #{node}"
    end

    def resolve_ident(node : Path, create_modules_if_missing = false)
      free_vars = @free_vars
      if free_vars && !node.global && (type = free_vars[node.names.first]?)
        target_type = type
        if node.names.size > 1
          target_type = lookup_type target_type, node.names[1 .. -1], node
        end
      else
        base_lookup = node.global ? mod : (@type_lookup || @scope || @types.last)
        target_type = lookup_type base_lookup, node, node

        unless target_type
          if create_modules_if_missing
            next_type = base_lookup
            node.names.each do |name|
              next_type = lookup_type base_lookup, [name], node
              if next_type
                if next_type.is_a?(ASTNode)
                  node.raise "execpted #{name} to be a type"
                end
              else
                next_type = NonGenericModuleType.new(@mod, base_lookup, name)

                if @mod.wants_doc? && (location = node.location)
                  next_type.locations << location
                end

                base_lookup.types[name] = next_type
              end
              base_lookup = next_type
            end
            target_type = next_type
          else
            similar_name = base_lookup.lookup_similar_type_name(node)
          end
        end
      end

      unless target_type
        error_msg = String.build do |msg|
          msg << "undefined constant #{node}"
          msg << @mod.colorize(" (did you mean '#{similar_name}'?)").yellow.bold if similar_name
        end
        node.raise error_msg
      end

      target_type
    end

    def lookup_type(base_type, names, node)
      base_type.lookup_type names
    rescue ex
      node.raise ex.message
    end

    def check_arg_primitive_like(node)
      type = check_primitive_like(node)

      real_type = type.remove_typedef
      if real_type.void?
        node.raise "can't use Void as argument type"
      end

      type
    end

    def check_primitive_like(node)
      type = node.type.instance_type

      unless type.primitive_like?
        msg = String.build do |msg|
          msg << "only primitive types, pointers, structs, unions, enums and tuples are allowed in lib declarations"
          msg << " (did you mean Int32?)" if type == @mod.int
          msg << " (did you mean Float32?)" if type == @mod.float
        end
        node.raise msg
      end

      if type.is_a?(TypeDefType) && type.typedef.fun?
        type = type.typedef
      end

      type
    end

    ## Literals

    def visit(node : Nop)
      node.type = @mod.nil
    end

    def visit(node : NilLiteral)
      node.type = @mod.nil
    end

    def visit(node : BoolLiteral)
      node.type = mod.bool
    end

    def visit(node : NumberLiteral)
      node.type = case node.kind
                  when :i8 then mod.int8
                  when :i16 then mod.int16
                  when :i32 then mod.int32
                  when :i64 then mod.int64
                  when :u8 then mod.uint8
                  when :u16 then mod.uint16
                  when :u32 then mod.uint32
                  when :u64 then mod.uint64
                  when :f32 then mod.float32
                  when :f64 then mod.float64
                  else raise "Invalid node kind: #{node.kind}"
                  end
    end

    def visit(node : CharLiteral)
      node.type = mod.char
    end

    def visit(node : SymbolLiteral)
      node.type = mod.symbol
      mod.symbols.add node.value
    end

    def visit(node : StringLiteral)
      node.type = mod.string
    end

    def visit(node : RegexLiteral)
      expand(node)
    end

    def visit(node : ArrayLiteral)
      if name = node.name
        name.accept self
        type = name.type.instance_type

        case type
        when GenericClassType
          type_name = type.name.split "::"

          path = Path.global(type_name).at(node.location)
          type_of = TypeOf.new(node.elements).at(node.location)
          generic = Generic.new(path, type_of).at(node.location)

          node.name = generic
        when GenericClassInstanceType
          # Nothing
        else
          type_name = type.to_s.split "::"
          path = Path.global(type_name).at(node.location)
          node.name = path
        end

        expand_named(node)
      else
        expand(node)
      end
    end

    def visit(node : HashLiteral)
      if name = node.name
        name.accept self
        type = name.type.instance_type

        case type
        when GenericClassType
          type_name = type.name.split "::"

          path = Path.global(type_name).at(node.location)
          type_of_keys = TypeOf.new(node.entries.map &.key).at(node.location)
          type_of_values = TypeOf.new(node.entries.map &.value).at(node.location)
          generic = Generic.new(path, [type_of_keys, type_of_values] of ASTNode).at(node.location)

          node.name = generic
        when GenericClassInstanceType
          # Nothing
        else
          type_name = type.to_s.split "::"

          path = Path.global(type_name).at(node.location)

          node.name = path
        end

        expand_named(node)
      else
        expand(node)
      end
    end

    def visit(node : And)
      expand(node)
    end

    def visit(node : Or)
      expand(node)
    end

    def visit(node : RangeLiteral)
      expand(node)
    end

    def visit(node : StringInterpolation)
      expand(node)
    end

    def visit(node : Case)
      expand(node)
      false
    end

    def expand(node)
      expand(node) { @mod.literal_expander.expand node }
    end

    def expand_named(node)
      expand(node) { @mod.literal_expander.expand_named node  }
    end

    def expand(node)
      expanded = yield
      expanded.accept self
      node.expanded = expanded
      node.bind_to expanded
      false
    end

    ## Helpers

    def current_type
      @types.last
    end

    def check_closured(var)
      return if @typeof_nest > 0

      if var.name == "self"
        check_self_closured
        return
      end

      context = current_context
      var_context = var.context
      if !var_context.same?(context)
        # If the contexts are not the same, it might be that we are in a block
        # inside a method, or a block inside another block. We don't want
        # those cases to closure a variable. So if any context is a block
        # we go to the block's context (a def or a fun literal) and compare
        # if those are the same to determine whether the variable is closured.
        context = context.context if context.is_a?(Block)
        var_context = var_context.context if var_context.is_a?(Block)

        closured = !context.same?(var_context)
        if closured
          var.closured = true

          # Go up and mark fun literal defs as closured until we get
          # to the context where the variable is defined
          visitor = self
          while visitor
            visitor_context = visitor.closure_context
            break if visitor_context == var_context

            visitor_context.closure = true if visitor_context.is_a?(Def)
            visitor = visitor.parent
          end
        end
      end
    end

    def check_self_closured
      if @scope && (context = @fun_literal_context) && context.is_a?(Def)
        context.self_closured = true

        # Go up and mark fun literal defs as closured until the top
        # (which should be when we leave the top Def)
        visitor = self
        while visitor
          visitor_context = visitor.closure_context
          visitor_context.closure = true if visitor_context.is_a?(Def)
          visitor = visitor.parent
        end
      end
    end

    def current_context
      @block_context || current_non_block_context
    end

    def current_non_block_context
      @typed_def || @mod
    end

    def closure_context
      context = current_context
      context = context.context if context.is_a?(Block)
      context
    end

    def lookup_var_or_instance_var(var : Var)
      @vars[var.name]
    end

    def lookup_var_or_instance_var(var : InstanceVar)
      scope = @scope as InstanceVarContainer
      scope.lookup_instance_var(var.name)
    end

    def lookup_var_or_instance_var(var)
      raise "Bug: trying to lookup var or instance var but got #{var}"
    end

    def bind_meta_var(var : Var)
      @meta_vars[var.name].bind_to(var)
    end

    def bind_meta_var(var : InstanceVar)
      # Nothing to do
    end

    def bind_meta_var(var)
      raise "Bug: trying to bind var or instance var but got #{var}"
    end

    def bind_initialize_instance_vars(owner)
      names_to_remove = [] of String

      @vars.each do |name, var|
        if name.starts_with? '@'
          if var.nil_if_read
            ivar = owner.lookup_instance_var(name)
            ivar.bind_to mod.nil_var
          end

          names_to_remove << name
        end
      end

      names_to_remove.each do |name|
        @meta_vars.delete name
        @vars.delete name
      end
    end

    def needs_type_filters?
      @needs_type_filters > 0
    end

    def request_type_filters
      @type_filters = nil
      @needs_type_filters += 1
      begin
        yield
      ensure
        @needs_type_filters -= 1
      end
    end

    def ignoring_type_filters
      needs_type_filters, @needs_type_filters = @needs_type_filters, 0
      begin
        yield
      ensure
        @needs_type_filters = needs_type_filters
      end
    end

    def lookup_similar_var_name(name)
      Levenshtein.find(name) do |finder|
        @vars.each_key do |var_name|
          finder.test(var_name)
        end
      end
    end

    def define_special_var(name, value)
      meta_var = (@meta_vars[name] ||= new_meta_var(name))
      meta_var.bind_to value
      meta_var.bind_to mod.nil_var unless meta_var.dependencies.any? &.same?(mod.nil_var)
      meta_var.assigned_to = true
      check_closured meta_var

      case meta_var.type
      when NilType, NilableType
        # OK
      else
        value.raise "'#{name}' only allows reference nilable types, not #{meta_var.type}"
      end

      @vars[name] = meta_var
      meta_var
    end

    def new_meta_var(name, context = current_context)
      meta_var = MetaVar.new(name)
      meta_var.context = context
      meta_var
    end

    def block=(@block)
      @block_context = @block
    end

    def inside_block?
      @untyped_def || @block_context
    end

    def inside_exp?
      @exp_nest > 0
    end

    def check_outside_block_or_exp(node, op)
      if inside_block?
        node.raise "can't #{op} inside block"
      end

      if inside_exp?
        node.raise "can't #{op} dynamically"
      end
    end

    def pushing_type(type)
      @types.push type
      yield
      @types.pop
    end

    def visit(node : Require | When | Unless | MultiAssign | Until | MacroLiteral)
      raise "Bug: #{node.class_desc} node '#{node}' (#{node.location}) should have been eliminated in normalize"
    end
  end
end
